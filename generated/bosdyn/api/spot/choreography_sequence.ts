/* eslint-disable */
import { Timestamp } from "../../../google/protobuf/timestamp";
import Long from "long";
import { RequestHeader, ResponseHeader } from "../header";
import { Lease, LeaseUseResult } from "../lease";
import { Duration } from "../../../google/protobuf/duration";
import { SE3Pose, Vec3Value, Quaternion } from "../geometry";
import { DataChunk } from "../data_chunk";
import {
  JumpParams,
  RotateBodyParams,
  StepParams,
  ButtCircleParams,
  TurnParams,
  Pace2StepParams,
  TwerkParams,
  ChickenHeadParams,
  ClapParams,
  FrontUpParams,
  SwayParams,
  BodyHoldParams,
  ArmMoveParams,
  KneelLegMoveParams,
  RunningManParams,
  KneelCircleParams,
  GripperParams,
  HopParams,
  RandomRotateParams,
  CrawlParams,
  SideParams,
  BourreeParams,
  WorkspaceArmMoveParams,
  Figure8Params,
  KneelLegMove2Params,
  FidgetStandParams,
  GotoParams,
  FrameSnapshotParams,
  SetColorParams,
  RippleColorParams,
  FadeColorParams,
  IndependentColorParams,
  AnimateParams,
  EulerZYXValue,
} from "./choreography_params";
import _m0 from "protobufjs/minimal";
import {
  StringValue,
  DoubleValue,
  BoolValue,
} from "../../../google/protobuf/wrappers";

export const protobufPackage = "bosdyn.api.spot";

/** Request a list of all possible moves and the associated parameters (min/max values). */
export interface ListAllMovesRequest {
  /** Common request header */
  header: RequestHeader | undefined;
}

/** Response for ListAllMoves that defines the list of available moves and their parameter types. */
export interface ListAllMovesResponse {
  /** Common response header */
  header: ResponseHeader | undefined;
  /** List of moves that the robot knows about. */
  moves: MoveInfo[];
  /** A copy of the MoveParamsConfig.txt that the robot is using. */
  moveParamConfig: string;
}

/** Request a list of all playable choreography sequences that the robot knows about */
export interface ListAllSequencesRequest {
  /** Common request header */
  header: RequestHeader | undefined;
}

/**  */
export interface ListAllSequencesResponse {
  /** Common response header. */
  header: ResponseHeader | undefined;
  /** List of choreography sequences the robot knows about. */
  knownSequences: string[];
}

export interface UploadChoreographyRequest {
  /** Common request header. */
  header: RequestHeader | undefined;
  /** ChoreographySequence to upload and store in memory */
  choreographySequence: ChoreographySequence | undefined;
  /**
   * Should we run a sequences that has correctable errors?
   * If true, the service will fix any correctable errors and run the corrected choreography
   * sequence. If false, the service will reject a choreography sequence that has any errors.
   */
  nonStrictParsing: boolean;
}

export interface UploadChoreographyResponse {
  /**
   * Common response header. If the dance upload is invalid, the header INVALID request error will
   * be set, which means that the choreography did not respect bounds of the parameters or has
   * other attributes missing or incorrect.
   */
  header: ResponseHeader | undefined;
  /**
   * If the uploaded choreography is invalid (will throw a header InvalidRequest status), then
   * certain warning messages will be populated here to indicate which choreography moves or
   * parameters violated constraints of the robot.
   */
  warnings: string[];
}

export interface UploadAnimatedMoveRequest {
  /** Common request header */
  header: RequestHeader | undefined;
  /**
   * Unique ID for the animated moves. This will be automatically generated by the client
   * and is used to uniquely identify the entire animation by creating a hash from the Animation
   * protobuf message after serialization. The ID will be conveyed within the MoveInfo protobuf
   * message in the ListAllMoves RPC. This ID allows the choreography client to only reupload
   * animations that have changed or do not exist on robot already.
   */
  animatedMoveGeneratedId: string | undefined;
  /** AnimatedMove to upload to the robot and create a dance move from. */
  animatedMove: Animation | undefined;
}

export interface UploadAnimatedMoveResponse {
  /** Common response header. */
  header: ResponseHeader | undefined;
  status: UploadAnimatedMoveResponse_Status;
  /**
   * If the uploaded animated move is invalid (will throw a STATUS_ANIMATION_VALIDATION_FAILED), then
   * warning messages describing the failure cases will be populated here to indicate which
   * parts of the animated move failed. Note: there could be some warning messages even when an animation
   * is marked as ok.
   */
  warnings: string[];
}

export enum UploadAnimatedMoveResponse_Status {
  /** STATUS_UNKNOWN - Do not use. */
  STATUS_UNKNOWN = 0,
  /** STATUS_OK - Uploading + parsing the animated move succeeded. */
  STATUS_OK = 1,
  /** STATUS_ANIMATION_VALIDATION_FAILED - The animated move is considered invalid, see the warnings. */
  STATUS_ANIMATION_VALIDATION_FAILED = 2,
  UNRECOGNIZED = -1,
}

export function uploadAnimatedMoveResponse_StatusFromJSON(
  object: any
): UploadAnimatedMoveResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return UploadAnimatedMoveResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_OK":
      return UploadAnimatedMoveResponse_Status.STATUS_OK;
    case 2:
    case "STATUS_ANIMATION_VALIDATION_FAILED":
      return UploadAnimatedMoveResponse_Status.STATUS_ANIMATION_VALIDATION_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UploadAnimatedMoveResponse_Status.UNRECOGNIZED;
  }
}

export function uploadAnimatedMoveResponse_StatusToJSON(
  object: UploadAnimatedMoveResponse_Status
): string {
  switch (object) {
    case UploadAnimatedMoveResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case UploadAnimatedMoveResponse_Status.STATUS_OK:
      return "STATUS_OK";
    case UploadAnimatedMoveResponse_Status.STATUS_ANIMATION_VALIDATION_FAILED:
      return "STATUS_ANIMATION_VALIDATION_FAILED";
    case UploadAnimatedMoveResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ExecuteChoreographyRequest {
  /** Common request header */
  header: RequestHeader | undefined;
  /** The string name of the ChoreographySequence to use. */
  choreographySequenceName: string;
  /**
   * The absolute time to start the choreography at. This should be in the robot's clock so we can
   * synchronize music playing and the robot's choreography.
   */
  startTime: Date | undefined;
  /** The slice (betas/sub-beats) that the choreography should begin excution at. */
  choreographyStartingSlice: number;
  /** / The Lease to show ownership of the robot body. */
  lease: Lease | undefined;
}

export interface ExecuteChoreographyResponse {
  /** Common response header */
  header: ResponseHeader | undefined;
  leaseUseResult: LeaseUseResult | undefined;
  status: ExecuteChoreographyResponse_Status;
}

export enum ExecuteChoreographyResponse_Status {
  STATUS_UNKNOWN = 0,
  STATUS_OK = 1,
  STATUS_INVALID_UPLOADED_CHOREOGRAPHY = 2,
  STATUS_ROBOT_COMMAND_ISSUES = 3,
  STATUS_LEASE_ERROR = 4,
  UNRECOGNIZED = -1,
}

export function executeChoreographyResponse_StatusFromJSON(
  object: any
): ExecuteChoreographyResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return ExecuteChoreographyResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_OK":
      return ExecuteChoreographyResponse_Status.STATUS_OK;
    case 2:
    case "STATUS_INVALID_UPLOADED_CHOREOGRAPHY":
      return ExecuteChoreographyResponse_Status.STATUS_INVALID_UPLOADED_CHOREOGRAPHY;
    case 3:
    case "STATUS_ROBOT_COMMAND_ISSUES":
      return ExecuteChoreographyResponse_Status.STATUS_ROBOT_COMMAND_ISSUES;
    case 4:
    case "STATUS_LEASE_ERROR":
      return ExecuteChoreographyResponse_Status.STATUS_LEASE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecuteChoreographyResponse_Status.UNRECOGNIZED;
  }
}

export function executeChoreographyResponse_StatusToJSON(
  object: ExecuteChoreographyResponse_Status
): string {
  switch (object) {
    case ExecuteChoreographyResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case ExecuteChoreographyResponse_Status.STATUS_OK:
      return "STATUS_OK";
    case ExecuteChoreographyResponse_Status.STATUS_INVALID_UPLOADED_CHOREOGRAPHY:
      return "STATUS_INVALID_UPLOADED_CHOREOGRAPHY";
    case ExecuteChoreographyResponse_Status.STATUS_ROBOT_COMMAND_ISSUES:
      return "STATUS_ROBOT_COMMAND_ISSUES";
    case ExecuteChoreographyResponse_Status.STATUS_LEASE_ERROR:
      return "STATUS_LEASE_ERROR";
    case ExecuteChoreographyResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface StartRecordingStateRequest {
  /** Common request header */
  header: RequestHeader | undefined;
  /**
   * How long should the robot record for if no stop RPC is sent. A recording session can be
   * extended by setting the recording_session_id below to a non-zero value matching the ID for the
   * current recording session.
   * For both start and continuation commands, the service will stop recording at
   * end_time = (system time when the Start/Continue RPC is received) + (continue_recording_duration),
   * unless another continuation request updates this end time.
   * The robot has an internal maximum recording time of 5 minutes for the complete session log.
   */
  continueRecordingDuration: Duration | undefined;
  /**
   * Provide the unique identifier of the recording session to extend the recording end time for.
   * If the recording_session_id is 0, then it will create a new session and the robot will clear
   * the recorded robot state buffer and restart recording.
   * If this is a continuation of an existing recording session, than the robot will continue
   * to record until the specified end time.
   */
  recordingSessionId: number;
}

export interface StartRecordingStateResponse {
  /** Common response header */
  header: ResponseHeader | undefined;
  status: StartRecordingStateResponse_Status;
  /** Unique identifier for the current recording session */
  recordingSessionId: number;
}

/** The status for the start recording request. */
export enum StartRecordingStateResponse_Status {
  /** STATUS_UNKNOWN - Status unknown; do not use. */
  STATUS_UNKNOWN = 0,
  /**
   * STATUS_OK - The request succeeded and choreography has either started, or continued with an extended
   * duration based on if a session_id was provided.
   */
  STATUS_OK = 1,
  /**
   * STATUS_UNKNOWN_RECORDING_SESSION_ID - The provided recording_session_id is unknown: it must either be 0 (start a new recording log)
   * or it can match the current recording session id returned by the most recent start recording request.
   */
  STATUS_UNKNOWN_RECORDING_SESSION_ID = 2,
  /**
   * STATUS_RECORDING_BUFFER_FULL - The Choreography Service's internal buffer is filled. It will record for a maximum of 5 minutes. It
   * will stop recording, but save the recorded data until
   */
  STATUS_RECORDING_BUFFER_FULL = 3,
  UNRECOGNIZED = -1,
}

export function startRecordingStateResponse_StatusFromJSON(
  object: any
): StartRecordingStateResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return StartRecordingStateResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_OK":
      return StartRecordingStateResponse_Status.STATUS_OK;
    case 2:
    case "STATUS_UNKNOWN_RECORDING_SESSION_ID":
      return StartRecordingStateResponse_Status.STATUS_UNKNOWN_RECORDING_SESSION_ID;
    case 3:
    case "STATUS_RECORDING_BUFFER_FULL":
      return StartRecordingStateResponse_Status.STATUS_RECORDING_BUFFER_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StartRecordingStateResponse_Status.UNRECOGNIZED;
  }
}

export function startRecordingStateResponse_StatusToJSON(
  object: StartRecordingStateResponse_Status
): string {
  switch (object) {
    case StartRecordingStateResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case StartRecordingStateResponse_Status.STATUS_OK:
      return "STATUS_OK";
    case StartRecordingStateResponse_Status.STATUS_UNKNOWN_RECORDING_SESSION_ID:
      return "STATUS_UNKNOWN_RECORDING_SESSION_ID";
    case StartRecordingStateResponse_Status.STATUS_RECORDING_BUFFER_FULL:
      return "STATUS_RECORDING_BUFFER_FULL";
    case StartRecordingStateResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface StopRecordingStateRequest {
  /** Common request header */
  header: RequestHeader | undefined;
}

export interface StopRecordingStateResponse {
  /** Common response header */
  header: ResponseHeader | undefined;
}

export interface DownloadRobotStateLogRequest {
  /** Common request header */
  header: RequestHeader | undefined;
  /** Which data should we download. */
  logType: DownloadRobotStateLogRequest_LogType;
}

export enum DownloadRobotStateLogRequest_LogType {
  /** LOG_TYPE_UNKNOWN - Unknown. Do not use. */
  LOG_TYPE_UNKNOWN = 0,
  /**
   * LOG_TYPE_MANUAL - The robot state information recorded from the time of the manual start RPC (StartRecordingState)
   * to either {the time of the manual stop RPC (StopRecordingState), the time of the download logs RPC,
   * or the time of the internal service's buffer filling up}.
   */
  LOG_TYPE_MANUAL = 1,
  /**
   * LOG_TYPE_LAST_CHOREOGRAPHY - The robot will automatically record robot state information for the entire duration of an executing
   * choreography in addition to any manual logging. This log type will download this information for the
   * last completed choreography.
   */
  LOG_TYPE_LAST_CHOREOGRAPHY = 2,
  UNRECOGNIZED = -1,
}

export function downloadRobotStateLogRequest_LogTypeFromJSON(
  object: any
): DownloadRobotStateLogRequest_LogType {
  switch (object) {
    case 0:
    case "LOG_TYPE_UNKNOWN":
      return DownloadRobotStateLogRequest_LogType.LOG_TYPE_UNKNOWN;
    case 1:
    case "LOG_TYPE_MANUAL":
      return DownloadRobotStateLogRequest_LogType.LOG_TYPE_MANUAL;
    case 2:
    case "LOG_TYPE_LAST_CHOREOGRAPHY":
      return DownloadRobotStateLogRequest_LogType.LOG_TYPE_LAST_CHOREOGRAPHY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DownloadRobotStateLogRequest_LogType.UNRECOGNIZED;
  }
}

export function downloadRobotStateLogRequest_LogTypeToJSON(
  object: DownloadRobotStateLogRequest_LogType
): string {
  switch (object) {
    case DownloadRobotStateLogRequest_LogType.LOG_TYPE_UNKNOWN:
      return "LOG_TYPE_UNKNOWN";
    case DownloadRobotStateLogRequest_LogType.LOG_TYPE_MANUAL:
      return "LOG_TYPE_MANUAL";
    case DownloadRobotStateLogRequest_LogType.LOG_TYPE_LAST_CHOREOGRAPHY:
      return "LOG_TYPE_LAST_CHOREOGRAPHY";
    case DownloadRobotStateLogRequest_LogType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LoggedJoints {
  /** front left leg joint angles. */
  fl: LegJointAngles | undefined;
  /** front right leg joint angles. */
  fr: LegJointAngles | undefined;
  /** hind left leg joint angles. */
  hl: LegJointAngles | undefined;
  /** hind right leg joint angles. */
  hr: LegJointAngles | undefined;
  /** Full set of joint angles for the arm and gripper. */
  arm: ArmJointAngles | undefined;
  gripperAngle: number | undefined;
}

export interface LoggedFootContacts {
  /** Boolean indicating whether or not the robot's foot is in contact with the ground. */
  frContact: boolean;
  flContact: boolean;
  hrContact: boolean;
  hlContact: boolean;
}

export interface LoggedStateKeyFrame {
  /** Full set of joint angles for the robot. */
  jointAngles: LoggedJoints | undefined;
  /** Foot contacts for the robot. */
  footContactState: LoggedFootContacts | undefined;
  /**
   * The current pose of the robot body in animation frame. The animation frame is defined
   * based on the robot's footprint when the log first started recording.
   */
  animationTformBody: SE3Pose | undefined;
  /** The timestamp (in robot time) for the key frame. */
  timestamp: Date | undefined;
}

export interface ChoreographyStateLog {
  /**
   * A set of key frames recorded at a high rate. The key frames can be for the duration of an executing
   * choreography or for the duration of a manual recorded log (triggered by the StartRecordingState and
   * StopRecordingState RPCs). The specific set of keyframes is specified by the LogType when requesting
   * to download the data.
   */
  keyFrames: LoggedStateKeyFrame[];
}

export interface DownloadRobotStateLogResponse {
  /** Common response header */
  header: ResponseHeader | undefined;
  /** Return status for the request. */
  status: DownloadRobotStateLogResponse_Status;
  /**
   * Chunk of data to download. Responses are sent in sequence until the
   * data chunk is complete. After receiving all chunks, concatenate them
   * into a single byte string. Then, deserialize the byte string into an
   * ChoreographyStateLog object.
   */
  chunk: DataChunk | undefined;
}

export enum DownloadRobotStateLogResponse_Status {
  /** STATUS_UNKNOWN - Status unknown. Do not use. */
  STATUS_UNKNOWN = 0,
  /** STATUS_OK - The log data downloaded successfully and is complete. */
  STATUS_OK = 1,
  /** STATUS_NO_RECORDED_INFORMATION - Error where there is no robot state information logged in the choreography service. */
  STATUS_NO_RECORDED_INFORMATION = 2,
  /**
   * STATUS_INCOMPLETE_DATA - Error where the complete duration of the recorded session caused the service's recording
   * buffer to fill up. When full, the robot will stop recording but preserve whatever was
   * recorded until that point. The robot has an internal maximum recording time of 5 minutes.
   * The data streamed in this response will go from the start time until the time the buffer
   * was filled.
   */
  STATUS_INCOMPLETE_DATA = 3,
  UNRECOGNIZED = -1,
}

export function downloadRobotStateLogResponse_StatusFromJSON(
  object: any
): DownloadRobotStateLogResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return DownloadRobotStateLogResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_OK":
      return DownloadRobotStateLogResponse_Status.STATUS_OK;
    case 2:
    case "STATUS_NO_RECORDED_INFORMATION":
      return DownloadRobotStateLogResponse_Status.STATUS_NO_RECORDED_INFORMATION;
    case 3:
    case "STATUS_INCOMPLETE_DATA":
      return DownloadRobotStateLogResponse_Status.STATUS_INCOMPLETE_DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DownloadRobotStateLogResponse_Status.UNRECOGNIZED;
  }
}

export function downloadRobotStateLogResponse_StatusToJSON(
  object: DownloadRobotStateLogResponse_Status
): string {
  switch (object) {
    case DownloadRobotStateLogResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case DownloadRobotStateLogResponse_Status.STATUS_OK:
      return "STATUS_OK";
    case DownloadRobotStateLogResponse_Status.STATUS_NO_RECORDED_INFORMATION:
      return "STATUS_NO_RECORDED_INFORMATION";
    case DownloadRobotStateLogResponse_Status.STATUS_INCOMPLETE_DATA:
      return "STATUS_INCOMPLETE_DATA";
    case DownloadRobotStateLogResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines varying parameters for a particular instance of a move. */
export interface MoveParams {
  /** Unique ID of the move type that these params are associated with. */
  type: string;
  /** How many slices since the start of the song this move should be executed at. */
  startSlice: number;
  /**
   * The number of slices (beats/sub-beats) that this move is supposed to last for. If the move
   * was extendable, then this corresponds to the number of slices that the user requested.
   */
  requestedSlices: number;
  jumpParams: JumpParams | undefined;
  rotateBodyParams: RotateBodyParams | undefined;
  stepParams: StepParams | undefined;
  buttCircleParams: ButtCircleParams | undefined;
  turnParams: TurnParams | undefined;
  pace2stepParams: Pace2StepParams | undefined;
  twerkParams: TwerkParams | undefined;
  chickenHeadParams: ChickenHeadParams | undefined;
  clapParams: ClapParams | undefined;
  frontUpParams: FrontUpParams | undefined;
  swayParams: SwayParams | undefined;
  bodyHoldParams: BodyHoldParams | undefined;
  armMoveParams: ArmMoveParams | undefined;
  kneelLegMoveParams: KneelLegMoveParams | undefined;
  runningManParams: RunningManParams | undefined;
  kneelCircleParams: KneelCircleParams | undefined;
  gripperParams: GripperParams | undefined;
  hopParams: HopParams | undefined;
  randomRotateParams: RandomRotateParams | undefined;
  crawlParams: CrawlParams | undefined;
  sideParams: SideParams | undefined;
  bourreeParams: BourreeParams | undefined;
  workspaceArmMoveParams: WorkspaceArmMoveParams | undefined;
  figure8Params: Figure8Params | undefined;
  kneelLegMove2Params: KneelLegMove2Params | undefined;
  fidgetStandParams: FidgetStandParams | undefined;
  gotoParams: GotoParams | undefined;
  frameSnapshotParams: FrameSnapshotParams | undefined;
  setColorParams: SetColorParams | undefined;
  rippleColorParams: RippleColorParams | undefined;
  fadeColorParams: FadeColorParams | undefined;
  independentColorParams: IndependentColorParams | undefined;
  animateParams: AnimateParams | undefined;
}

/** Defines properties of a choreography move. */
export interface MoveInfo {
  /** Unique ID of the move type. */
  name: string;
  /** The duration of this move in slices (usually 1/4 beats). */
  moveLengthSlices: number;
  /** The duration of this move in seconds.  If specified, overrides move_length_slices. */
  moveLengthTime: number;
  /** If true, the duration may be adjusted from the default specified by move_length_slices or move_length_time. */
  isExtendable: boolean;
  /**
   * Bounds on the duration may be adjusted in slices (usually 1/4 beats).
   * These apply to extendable moves, but may also override move_length_time for some BPM.
   */
  minMoveLengthSlices: number;
  maxMoveLengthSlices: number;
  /**
   * Bounds on the duration in time.
   * These apply to extendable moves, but may also override move_length_slices for some BPM.
   */
  minTime: number;
  maxTime: number;
  /** The admissible states the robot can be in currently for this move to execute. */
  entranceStates: MoveInfo_TransitionState[];
  /** The state of the robot after the move is complete. */
  exitState: MoveInfo_TransitionState;
  /** Indicators as to which parts of the robot that the move controls. */
  controlsArm: boolean;
  controlsLegs: boolean;
  controlsBody: boolean;
  controlsGripper: boolean;
  controlsLights: boolean;
  controlsAnnotations: boolean;
  /** Information for the GUI tool to visualize the sequence move info. */
  display: ChoreographerDisplayInfo | undefined;
  /**
   * Unique ID for the animated moves. This is sent with the UploadAnimatedMove request and use
   * to track which version of the animated move is currently saved on robot. The ID can be unset,
   * meaning the RPC which uploaded the animation did not provide an identifying hash.
   */
  animatedMoveGeneratedId: string | undefined;
}

/** The state that the robot is in at the start or end of a move. */
export enum MoveInfo_TransitionState {
  /** TRANSITION_STATE_UNKNOWN - Unknown or unset state. */
  TRANSITION_STATE_UNKNOWN = 0,
  /** TRANSITION_STATE_STAND - The robot is in a normal (standing) state. */
  TRANSITION_STATE_STAND = 1,
  /** TRANSITION_STATE_KNEEL - The robot is kneeling down. */
  TRANSITION_STATE_KNEEL = 2,
  /** TRANSITION_STATE_SIT - The robot is sitting. */
  TRANSITION_STATE_SIT = 3,
  /** TRANSITION_STATE_SPRAWL - The robot requires a self-right. */
  TRANSITION_STATE_SPRAWL = 4,
  UNRECOGNIZED = -1,
}

export function moveInfo_TransitionStateFromJSON(
  object: any
): MoveInfo_TransitionState {
  switch (object) {
    case 0:
    case "TRANSITION_STATE_UNKNOWN":
      return MoveInfo_TransitionState.TRANSITION_STATE_UNKNOWN;
    case 1:
    case "TRANSITION_STATE_STAND":
      return MoveInfo_TransitionState.TRANSITION_STATE_STAND;
    case 2:
    case "TRANSITION_STATE_KNEEL":
      return MoveInfo_TransitionState.TRANSITION_STATE_KNEEL;
    case 3:
    case "TRANSITION_STATE_SIT":
      return MoveInfo_TransitionState.TRANSITION_STATE_SIT;
    case 4:
    case "TRANSITION_STATE_SPRAWL":
      return MoveInfo_TransitionState.TRANSITION_STATE_SPRAWL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MoveInfo_TransitionState.UNRECOGNIZED;
  }
}

export function moveInfo_TransitionStateToJSON(
  object: MoveInfo_TransitionState
): string {
  switch (object) {
    case MoveInfo_TransitionState.TRANSITION_STATE_UNKNOWN:
      return "TRANSITION_STATE_UNKNOWN";
    case MoveInfo_TransitionState.TRANSITION_STATE_STAND:
      return "TRANSITION_STATE_STAND";
    case MoveInfo_TransitionState.TRANSITION_STATE_KNEEL:
      return "TRANSITION_STATE_KNEEL";
    case MoveInfo_TransitionState.TRANSITION_STATE_SIT:
      return "TRANSITION_STATE_SIT";
    case MoveInfo_TransitionState.TRANSITION_STATE_SPRAWL:
      return "TRANSITION_STATE_SPRAWL";
    case MoveInfo_TransitionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information for the Choreographer to display. */
export interface ChoreographerDisplayInfo {
  color: ChoreographerDisplayInfo_Color | undefined;
  /**
   * For the GUI, these are marked events in steps. For example if the move puts a foot down, the
   * mark might be exactly when the foot is placed on the ground, relative to the start of the
   * move.
   */
  markers: number[];
  /** Textual description to be displayed in the GUI. */
  description: string;
  /** Image path (local to the UI) to display as an icon. May be an animated gif. */
  image: string;
  category: ChoreographerDisplayInfo_Category;
}

/**
 * Move Category affects the grouping in the choreographer list view, as well as the color it's
 * displayed with.
 */
export enum ChoreographerDisplayInfo_Category {
  CATEGORY_UNKNOWN = 0,
  CATEGORY_BODY = 1,
  CATEGORY_STEP = 2,
  CATEGORY_DYNAMIC = 3,
  CATEGORY_TRANSITION = 4,
  CATEGORY_KNEEL = 5,
  CATEGORY_ARM = 6,
  CATEGORY_ANIMATION = 7,
  CATEGORY_MPC = 8,
  CATEGORY_LIGHTS = 9,
  CATEGORY_ANNOTATIONS = 10,
  UNRECOGNIZED = -1,
}

export function choreographerDisplayInfo_CategoryFromJSON(
  object: any
): ChoreographerDisplayInfo_Category {
  switch (object) {
    case 0:
    case "CATEGORY_UNKNOWN":
      return ChoreographerDisplayInfo_Category.CATEGORY_UNKNOWN;
    case 1:
    case "CATEGORY_BODY":
      return ChoreographerDisplayInfo_Category.CATEGORY_BODY;
    case 2:
    case "CATEGORY_STEP":
      return ChoreographerDisplayInfo_Category.CATEGORY_STEP;
    case 3:
    case "CATEGORY_DYNAMIC":
      return ChoreographerDisplayInfo_Category.CATEGORY_DYNAMIC;
    case 4:
    case "CATEGORY_TRANSITION":
      return ChoreographerDisplayInfo_Category.CATEGORY_TRANSITION;
    case 5:
    case "CATEGORY_KNEEL":
      return ChoreographerDisplayInfo_Category.CATEGORY_KNEEL;
    case 6:
    case "CATEGORY_ARM":
      return ChoreographerDisplayInfo_Category.CATEGORY_ARM;
    case 7:
    case "CATEGORY_ANIMATION":
      return ChoreographerDisplayInfo_Category.CATEGORY_ANIMATION;
    case 8:
    case "CATEGORY_MPC":
      return ChoreographerDisplayInfo_Category.CATEGORY_MPC;
    case 9:
    case "CATEGORY_LIGHTS":
      return ChoreographerDisplayInfo_Category.CATEGORY_LIGHTS;
    case 10:
    case "CATEGORY_ANNOTATIONS":
      return ChoreographerDisplayInfo_Category.CATEGORY_ANNOTATIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChoreographerDisplayInfo_Category.UNRECOGNIZED;
  }
}

export function choreographerDisplayInfo_CategoryToJSON(
  object: ChoreographerDisplayInfo_Category
): string {
  switch (object) {
    case ChoreographerDisplayInfo_Category.CATEGORY_UNKNOWN:
      return "CATEGORY_UNKNOWN";
    case ChoreographerDisplayInfo_Category.CATEGORY_BODY:
      return "CATEGORY_BODY";
    case ChoreographerDisplayInfo_Category.CATEGORY_STEP:
      return "CATEGORY_STEP";
    case ChoreographerDisplayInfo_Category.CATEGORY_DYNAMIC:
      return "CATEGORY_DYNAMIC";
    case ChoreographerDisplayInfo_Category.CATEGORY_TRANSITION:
      return "CATEGORY_TRANSITION";
    case ChoreographerDisplayInfo_Category.CATEGORY_KNEEL:
      return "CATEGORY_KNEEL";
    case ChoreographerDisplayInfo_Category.CATEGORY_ARM:
      return "CATEGORY_ARM";
    case ChoreographerDisplayInfo_Category.CATEGORY_ANIMATION:
      return "CATEGORY_ANIMATION";
    case ChoreographerDisplayInfo_Category.CATEGORY_MPC:
      return "CATEGORY_MPC";
    case ChoreographerDisplayInfo_Category.CATEGORY_LIGHTS:
      return "CATEGORY_LIGHTS";
    case ChoreographerDisplayInfo_Category.CATEGORY_ANNOTATIONS:
      return "CATEGORY_ANNOTATIONS";
    case ChoreographerDisplayInfo_Category.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Color of the object. Set it to override the default category color. */
export interface ChoreographerDisplayInfo_Color {
  /** RGB values for color ranging from [0,255]. */
  r: number;
  g: number;
  b: number;
  /** Alpha value for the coloration ranges from [0,1]. */
  a: number;
}

/** Represents a particular choreography sequence, made up of MoveParams. */
export interface ChoreographySequence {
  /** Display name or file name associated with the choreography sequence. */
  name: string;
  /**
   * Number of slices per minute in the choreography sequence. Typically a slice will correspond
   * to 1/4 a beat.
   */
  slicesPerMinute: number;
  /** All of the moves in this choreography sequence. */
  moves: MoveParams[];
}

/**
 * Describes the metadata and information only used by the Choreographer GUI, which isn't used in
 * the API
 */
export interface ChoreographerSave {
  /** The main ChoreographySequence that makes up the dance and is sent to the robot. */
  choreographySequence: ChoreographySequence | undefined;
  /** If specified this is the UI local path of the music to load. */
  musicFile: string;
  /**
   * UI specific member that describes exactly when the music should start, in slices. This is for
   * time sync issues.
   */
  musicStartSlice: number;
  /** The start slice for the choreographer save. */
  choreographyStartSlice: number;
}

/** Represents an animated dance move that can be used whithin choreographies after uploading. */
export interface Animation {
  /** The name of the animated move, which is how it will be referenced in choreographies. */
  name: string;
  /**
   * The animated move is composed of animation keyframes, which specify the duration of
   * each frame. The keyframe describes the position of the body/arms/gripper.
   */
  animationKeyframes: AnimationKeyframe[];
  /** Indicators as to which parts of the robot that the move controls. */
  controlsArm: boolean;
  controlsLegs: boolean;
  controlsBody: boolean;
  controlsGripper: boolean;
  /** Track animated swing trajectories.  Otherwise, takes standard swings between animated liftoff and touchdown locations. */
  trackSwingTrajectories: boolean;
  /**
   * For moves that control the legs, but not the body.
   * If legs are specified by joint angles, we still need body roll and pitch to know the foot height.
   * If `assume_zero_roll_and_pitch` is true, they needn't be explicitly specified.
   */
  assumeZeroRollAndPitch: boolean;
  armPlayback: Animation_ArmPlayback;
  /** Optional bpm that the animation is successful at. */
  bpm: number;
  /**
   * When true, rescales the time of each keyframe slightly such that the move takes an
   * integer number of slices. If false/absent, the move will be padded or truncated slightly
   * to fit an integer number of slices.
   */
  retimeToIntegerSlices: boolean;
  /**
   * The different parameters (minimum, default, and maximum) that can change the move.
   * The min/max bounds are used by Choreographer to constrain the parameter widget, and will
   * also be used when uploading a ChoreographySequence containing the animation to validate
   * that the animated move is allowed.
   */
  minimumParameters: AnimateParams | undefined;
  defaultParameters: AnimateParams | undefined;
  maximumParameters: AnimateParams | undefined;
  /**
   * Indicates if the animated moves can be  shortened (the animated move will be cut off). Not
   * supported for leg moves.
   */
  truncatable: boolean;
  /**
   * Indicates if the animated moves can be stretched (animated move will loop). Not supported for
   * leg moves.
   */
  extendable: boolean;
  /** Indicates if the move should start in a neutral stand position. */
  neutralStart: boolean;
  /**
   * Step exactly at the animated locations, even at the expense of balance.
   * By default, the optimizer may adjust step locations slightly.
   */
  preciseSteps: boolean;
  /**
   * Time everything exactly as animated, even at the expense of balance.
   * By default, the optimizer may adjust timing slightly.
   */
  preciseTiming: boolean;
  /** If set true, this animation will not run unless the robot has an arm. */
  armRequired: boolean;
  /** If set true, this animation will not run unless the robot has no arm. */
  armProhibited: boolean;
  /** If the animation completes before the move's duration, freeze rather than looping. */
  noLooping: boolean;
}

/** Mode for hand trajectory playback */
export enum Animation_ArmPlayback {
  /**
   * ARM_PLAYBACK_DEFAULT - Playback as specified. Arm animations specified with joint angles playback in jointspace
   * and arm animations specified as hand poses playback in workspace.
   */
  ARM_PLAYBACK_DEFAULT = 0,
  /** ARM_PLAYBACK_JOINTSPACE - Playback in jointspace. Arm animation will be most consistent relative to the body */
  ARM_PLAYBACK_JOINTSPACE = 1,
  /**
   * ARM_PLAYBACK_WORKSPACE - Playback in workspace. Hand pose animation will be most consistent relative to the
   * current footprint. Reference frame is animation frame.
   */
  ARM_PLAYBACK_WORKSPACE = 2,
  /**
   * ARM_PLAYBACK_WORKSPACE_DANCE_FRAME - Playback in workspace with poses relative to the dance frame. hand pose animation will be
   * most consistent relative to a fixed point in the world.
   */
  ARM_PLAYBACK_WORKSPACE_DANCE_FRAME = 3,
  UNRECOGNIZED = -1,
}

export function animation_ArmPlaybackFromJSON(
  object: any
): Animation_ArmPlayback {
  switch (object) {
    case 0:
    case "ARM_PLAYBACK_DEFAULT":
      return Animation_ArmPlayback.ARM_PLAYBACK_DEFAULT;
    case 1:
    case "ARM_PLAYBACK_JOINTSPACE":
      return Animation_ArmPlayback.ARM_PLAYBACK_JOINTSPACE;
    case 2:
    case "ARM_PLAYBACK_WORKSPACE":
      return Animation_ArmPlayback.ARM_PLAYBACK_WORKSPACE;
    case 3:
    case "ARM_PLAYBACK_WORKSPACE_DANCE_FRAME":
      return Animation_ArmPlayback.ARM_PLAYBACK_WORKSPACE_DANCE_FRAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Animation_ArmPlayback.UNRECOGNIZED;
  }
}

export function animation_ArmPlaybackToJSON(
  object: Animation_ArmPlayback
): string {
  switch (object) {
    case Animation_ArmPlayback.ARM_PLAYBACK_DEFAULT:
      return "ARM_PLAYBACK_DEFAULT";
    case Animation_ArmPlayback.ARM_PLAYBACK_JOINTSPACE:
      return "ARM_PLAYBACK_JOINTSPACE";
    case Animation_ArmPlayback.ARM_PLAYBACK_WORKSPACE:
      return "ARM_PLAYBACK_WORKSPACE";
    case Animation_ArmPlayback.ARM_PLAYBACK_WORKSPACE_DANCE_FRAME:
      return "ARM_PLAYBACK_WORKSPACE_DANCE_FRAME";
    case Animation_ArmPlayback.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AnimationKeyframe {
  /** Time from the start of the animation for this frame. */
  time: number;
  /**
   * Different body parts the animated move can control.
   * It can control multiple body parts at once.
   */
  gripper: AnimateGripper | undefined;
  arm: AnimateArm | undefined;
  body: AnimateBody | undefined;
  legs: AnimateLegs | undefined;
}

export interface AnimateGripper {
  gripperAngle: number | undefined;
}

export interface AnimateArm {
  /** Full arm joint angle specification. */
  jointAngles: ArmJointAngles | undefined;
  /** The hand position in the animation frame */
  handPose: AnimateArm_HandPose | undefined;
}

/**
 * An SE3 Pose for the hand where orientation is specified using either a quaternion or
 * euler angles
 */
export interface AnimateArm_HandPose {
  position: Vec3Value | undefined;
  /** The hand's orientation described with euler angles (yaw, pitch, roll). */
  eulerAngles: EulerZYXValue | undefined;
  /** The hand's orientation described with a quaternion. */
  quaternion: Quaternion | undefined;
}

/**
 * The AnimateArm keyframe describes the joint angles of the arm joints in radians.
 * Any joint not specified, will hold the previous angle it was at when the keyframe
 * begins. At least one arm joint must be specified.
 */
export interface ArmJointAngles {
  shoulder0: number | undefined;
  shoulder1: number | undefined;
  elbow0: number | undefined;
  elbow1: number | undefined;
  wrist0: number | undefined;
  wrist1: number | undefined;
}

/**
 * The AnimateBody keyframe describes the body's position and orientation. At least
 * one dimension of the body must be specified.
 */
export interface AnimateBody {
  /** The body position in the animation frame. */
  bodyPos: Vec3Value | undefined;
  /** The body's center of mass position in the animation frame. */
  comPos: Vec3Value | undefined;
  /** The body's orientation described with euler angles (yaw, pitch, roll). */
  eulerAngles: EulerZYXValue | undefined;
  /** The body's orientation described with a quaternion. */
  quaternion: Quaternion | undefined;
}

/** The AnimateLegs keyframe describes each leg using either joint angles or the foot position. */
export interface AnimateLegs {
  /** Front left leg. */
  fl: AnimateSingleLeg | undefined;
  /** Front right leg. */
  fr: AnimateSingleLeg | undefined;
  /** Hind left leg. */
  hl: AnimateSingleLeg | undefined;
  /** Hind right leg. */
  hr: AnimateSingleLeg | undefined;
}

/** A single leg keyframe to describe the leg motion. */
export interface AnimateSingleLeg {
  /** Full leg joint angle specification. */
  jointAngles: LegJointAngles | undefined;
  /** The foot position of the leg in the animation frame. */
  footPos: Vec3Value | undefined;
  /**
   * If true, the foot is in contact with the ground and standing. If false, the
   * foot is in swing. If unset, the contact will be inferred from the leg joint angles
   * or foot position.
   */
  stance: boolean | undefined;
}

/** Descprition of each leg joint angle (hip x/y and knee) in radians. */
export interface LegJointAngles {
  hipX: number;
  hipY: number;
  knee: number;
}

function createBaseListAllMovesRequest(): ListAllMovesRequest {
  return { header: undefined };
}

export const ListAllMovesRequest = {
  encode(
    message: ListAllMovesRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAllMovesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAllMovesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListAllMovesRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
    };
  },

  toJSON(message: ListAllMovesRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListAllMovesRequest>, I>>(
    object: I
  ): ListAllMovesRequest {
    const message = createBaseListAllMovesRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    return message;
  },
};

function createBaseListAllMovesResponse(): ListAllMovesResponse {
  return { header: undefined, moves: [], moveParamConfig: "" };
}

export const ListAllMovesResponse = {
  encode(
    message: ListAllMovesResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.moves) {
      MoveInfo.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.moveParamConfig !== "") {
      writer.uint32(26).string(message.moveParamConfig);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListAllMovesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAllMovesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.moves.push(MoveInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.moveParamConfig = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListAllMovesResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      moves: Array.isArray(object?.moves)
        ? object.moves.map((e: any) => MoveInfo.fromJSON(e))
        : [],
      moveParamConfig: isSet(object.moveParamConfig)
        ? String(object.moveParamConfig)
        : "",
    };
  },

  toJSON(message: ListAllMovesResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    if (message.moves) {
      obj.moves = message.moves.map((e) =>
        e ? MoveInfo.toJSON(e) : undefined
      );
    } else {
      obj.moves = [];
    }
    message.moveParamConfig !== undefined &&
      (obj.moveParamConfig = message.moveParamConfig);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListAllMovesResponse>, I>>(
    object: I
  ): ListAllMovesResponse {
    const message = createBaseListAllMovesResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.moves = object.moves?.map((e) => MoveInfo.fromPartial(e)) || [];
    message.moveParamConfig = object.moveParamConfig ?? "";
    return message;
  },
};

function createBaseListAllSequencesRequest(): ListAllSequencesRequest {
  return { header: undefined };
}

export const ListAllSequencesRequest = {
  encode(
    message: ListAllSequencesRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListAllSequencesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAllSequencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListAllSequencesRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
    };
  },

  toJSON(message: ListAllSequencesRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListAllSequencesRequest>, I>>(
    object: I
  ): ListAllSequencesRequest {
    const message = createBaseListAllSequencesRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    return message;
  },
};

function createBaseListAllSequencesResponse(): ListAllSequencesResponse {
  return { header: undefined, knownSequences: [] };
}

export const ListAllSequencesResponse = {
  encode(
    message: ListAllSequencesResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.knownSequences) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ListAllSequencesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAllSequencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.knownSequences.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListAllSequencesResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      knownSequences: Array.isArray(object?.knownSequences)
        ? object.knownSequences.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: ListAllSequencesResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    if (message.knownSequences) {
      obj.knownSequences = message.knownSequences.map((e) => e);
    } else {
      obj.knownSequences = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListAllSequencesResponse>, I>>(
    object: I
  ): ListAllSequencesResponse {
    const message = createBaseListAllSequencesResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.knownSequences = object.knownSequences?.map((e) => e) || [];
    return message;
  },
};

function createBaseUploadChoreographyRequest(): UploadChoreographyRequest {
  return {
    header: undefined,
    choreographySequence: undefined,
    nonStrictParsing: false,
  };
}

export const UploadChoreographyRequest = {
  encode(
    message: UploadChoreographyRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.choreographySequence !== undefined) {
      ChoreographySequence.encode(
        message.choreographySequence,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.nonStrictParsing === true) {
      writer.uint32(24).bool(message.nonStrictParsing);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UploadChoreographyRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadChoreographyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.choreographySequence = ChoreographySequence.decode(
            reader,
            reader.uint32()
          );
          break;
        case 3:
          message.nonStrictParsing = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UploadChoreographyRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
      choreographySequence: isSet(object.choreographySequence)
        ? ChoreographySequence.fromJSON(object.choreographySequence)
        : undefined,
      nonStrictParsing: isSet(object.nonStrictParsing)
        ? Boolean(object.nonStrictParsing)
        : false,
    };
  },

  toJSON(message: UploadChoreographyRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    message.choreographySequence !== undefined &&
      (obj.choreographySequence = message.choreographySequence
        ? ChoreographySequence.toJSON(message.choreographySequence)
        : undefined);
    message.nonStrictParsing !== undefined &&
      (obj.nonStrictParsing = message.nonStrictParsing);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UploadChoreographyRequest>, I>>(
    object: I
  ): UploadChoreographyRequest {
    const message = createBaseUploadChoreographyRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    message.choreographySequence =
      object.choreographySequence !== undefined &&
      object.choreographySequence !== null
        ? ChoreographySequence.fromPartial(object.choreographySequence)
        : undefined;
    message.nonStrictParsing = object.nonStrictParsing ?? false;
    return message;
  },
};

function createBaseUploadChoreographyResponse(): UploadChoreographyResponse {
  return { header: undefined, warnings: [] };
}

export const UploadChoreographyResponse = {
  encode(
    message: UploadChoreographyResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.warnings) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UploadChoreographyResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadChoreographyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 3:
          message.warnings.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UploadChoreographyResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      warnings: Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: UploadChoreographyResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    if (message.warnings) {
      obj.warnings = message.warnings.map((e) => e);
    } else {
      obj.warnings = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UploadChoreographyResponse>, I>>(
    object: I
  ): UploadChoreographyResponse {
    const message = createBaseUploadChoreographyResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.warnings = object.warnings?.map((e) => e) || [];
    return message;
  },
};

function createBaseUploadAnimatedMoveRequest(): UploadAnimatedMoveRequest {
  return {
    header: undefined,
    animatedMoveGeneratedId: undefined,
    animatedMove: undefined,
  };
}

export const UploadAnimatedMoveRequest = {
  encode(
    message: UploadAnimatedMoveRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.animatedMoveGeneratedId !== undefined) {
      StringValue.encode(
        { value: message.animatedMoveGeneratedId! },
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.animatedMove !== undefined) {
      Animation.encode(message.animatedMove, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UploadAnimatedMoveRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAnimatedMoveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        case 3:
          message.animatedMoveGeneratedId = StringValue.decode(
            reader,
            reader.uint32()
          ).value;
          break;
        case 2:
          message.animatedMove = Animation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UploadAnimatedMoveRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
      animatedMoveGeneratedId: isSet(object.animatedMoveGeneratedId)
        ? String(object.animatedMoveGeneratedId)
        : undefined,
      animatedMove: isSet(object.animatedMove)
        ? Animation.fromJSON(object.animatedMove)
        : undefined,
    };
  },

  toJSON(message: UploadAnimatedMoveRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    message.animatedMoveGeneratedId !== undefined &&
      (obj.animatedMoveGeneratedId = message.animatedMoveGeneratedId);
    message.animatedMove !== undefined &&
      (obj.animatedMove = message.animatedMove
        ? Animation.toJSON(message.animatedMove)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UploadAnimatedMoveRequest>, I>>(
    object: I
  ): UploadAnimatedMoveRequest {
    const message = createBaseUploadAnimatedMoveRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    message.animatedMoveGeneratedId =
      object.animatedMoveGeneratedId ?? undefined;
    message.animatedMove =
      object.animatedMove !== undefined && object.animatedMove !== null
        ? Animation.fromPartial(object.animatedMove)
        : undefined;
    return message;
  },
};

function createBaseUploadAnimatedMoveResponse(): UploadAnimatedMoveResponse {
  return { header: undefined, status: 0, warnings: [] };
}

export const UploadAnimatedMoveResponse = {
  encode(
    message: UploadAnimatedMoveResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.warnings) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UploadAnimatedMoveResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAnimatedMoveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        case 3:
          message.warnings.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UploadAnimatedMoveResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      status: isSet(object.status)
        ? uploadAnimatedMoveResponse_StatusFromJSON(object.status)
        : 0,
      warnings: Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: UploadAnimatedMoveResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    message.status !== undefined &&
      (obj.status = uploadAnimatedMoveResponse_StatusToJSON(message.status));
    if (message.warnings) {
      obj.warnings = message.warnings.map((e) => e);
    } else {
      obj.warnings = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UploadAnimatedMoveResponse>, I>>(
    object: I
  ): UploadAnimatedMoveResponse {
    const message = createBaseUploadAnimatedMoveResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.status = object.status ?? 0;
    message.warnings = object.warnings?.map((e) => e) || [];
    return message;
  },
};

function createBaseExecuteChoreographyRequest(): ExecuteChoreographyRequest {
  return {
    header: undefined,
    choreographySequenceName: "",
    startTime: undefined,
    choreographyStartingSlice: 0,
    lease: undefined,
  };
}

export const ExecuteChoreographyRequest = {
  encode(
    message: ExecuteChoreographyRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.choreographySequenceName !== "") {
      writer.uint32(18).string(message.choreographySequenceName);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.startTime),
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.choreographyStartingSlice !== 0) {
      writer.uint32(33).double(message.choreographyStartingSlice);
    }
    if (message.lease !== undefined) {
      Lease.encode(message.lease, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ExecuteChoreographyRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteChoreographyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.choreographySequenceName = reader.string();
          break;
        case 3:
          message.startTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          break;
        case 4:
          message.choreographyStartingSlice = reader.double();
          break;
        case 6:
          message.lease = Lease.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExecuteChoreographyRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
      choreographySequenceName: isSet(object.choreographySequenceName)
        ? String(object.choreographySequenceName)
        : "",
      startTime: isSet(object.startTime)
        ? fromJsonTimestamp(object.startTime)
        : undefined,
      choreographyStartingSlice: isSet(object.choreographyStartingSlice)
        ? Number(object.choreographyStartingSlice)
        : 0,
      lease: isSet(object.lease) ? Lease.fromJSON(object.lease) : undefined,
    };
  },

  toJSON(message: ExecuteChoreographyRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    message.choreographySequenceName !== undefined &&
      (obj.choreographySequenceName = message.choreographySequenceName);
    message.startTime !== undefined &&
      (obj.startTime = message.startTime.toISOString());
    message.choreographyStartingSlice !== undefined &&
      (obj.choreographyStartingSlice = message.choreographyStartingSlice);
    message.lease !== undefined &&
      (obj.lease = message.lease ? Lease.toJSON(message.lease) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExecuteChoreographyRequest>, I>>(
    object: I
  ): ExecuteChoreographyRequest {
    const message = createBaseExecuteChoreographyRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    message.choreographySequenceName = object.choreographySequenceName ?? "";
    message.startTime = object.startTime ?? undefined;
    message.choreographyStartingSlice = object.choreographyStartingSlice ?? 0;
    message.lease =
      object.lease !== undefined && object.lease !== null
        ? Lease.fromPartial(object.lease)
        : undefined;
    return message;
  },
};

function createBaseExecuteChoreographyResponse(): ExecuteChoreographyResponse {
  return { header: undefined, leaseUseResult: undefined, status: 0 };
}

export const ExecuteChoreographyResponse = {
  encode(
    message: ExecuteChoreographyResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.leaseUseResult !== undefined) {
      LeaseUseResult.encode(
        message.leaseUseResult,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ExecuteChoreographyResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteChoreographyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.leaseUseResult = LeaseUseResult.decode(
            reader,
            reader.uint32()
          );
          break;
        case 3:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExecuteChoreographyResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      leaseUseResult: isSet(object.leaseUseResult)
        ? LeaseUseResult.fromJSON(object.leaseUseResult)
        : undefined,
      status: isSet(object.status)
        ? executeChoreographyResponse_StatusFromJSON(object.status)
        : 0,
    };
  },

  toJSON(message: ExecuteChoreographyResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    message.leaseUseResult !== undefined &&
      (obj.leaseUseResult = message.leaseUseResult
        ? LeaseUseResult.toJSON(message.leaseUseResult)
        : undefined);
    message.status !== undefined &&
      (obj.status = executeChoreographyResponse_StatusToJSON(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExecuteChoreographyResponse>, I>>(
    object: I
  ): ExecuteChoreographyResponse {
    const message = createBaseExecuteChoreographyResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.leaseUseResult =
      object.leaseUseResult !== undefined && object.leaseUseResult !== null
        ? LeaseUseResult.fromPartial(object.leaseUseResult)
        : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseStartRecordingStateRequest(): StartRecordingStateRequest {
  return {
    header: undefined,
    continueRecordingDuration: undefined,
    recordingSessionId: 0,
  };
}

export const StartRecordingStateRequest = {
  encode(
    message: StartRecordingStateRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.continueRecordingDuration !== undefined) {
      Duration.encode(
        message.continueRecordingDuration,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.recordingSessionId !== 0) {
      writer.uint32(24).uint64(message.recordingSessionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StartRecordingStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRecordingStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.continueRecordingDuration = Duration.decode(
            reader,
            reader.uint32()
          );
          break;
        case 3:
          message.recordingSessionId = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRecordingStateRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
      continueRecordingDuration: isSet(object.continueRecordingDuration)
        ? Duration.fromJSON(object.continueRecordingDuration)
        : undefined,
      recordingSessionId: isSet(object.recordingSessionId)
        ? Number(object.recordingSessionId)
        : 0,
    };
  },

  toJSON(message: StartRecordingStateRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    message.continueRecordingDuration !== undefined &&
      (obj.continueRecordingDuration = message.continueRecordingDuration
        ? Duration.toJSON(message.continueRecordingDuration)
        : undefined);
    message.recordingSessionId !== undefined &&
      (obj.recordingSessionId = Math.round(message.recordingSessionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRecordingStateRequest>, I>>(
    object: I
  ): StartRecordingStateRequest {
    const message = createBaseStartRecordingStateRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    message.continueRecordingDuration =
      object.continueRecordingDuration !== undefined &&
      object.continueRecordingDuration !== null
        ? Duration.fromPartial(object.continueRecordingDuration)
        : undefined;
    message.recordingSessionId = object.recordingSessionId ?? 0;
    return message;
  },
};

function createBaseStartRecordingStateResponse(): StartRecordingStateResponse {
  return { header: undefined, status: 0, recordingSessionId: 0 };
}

export const StartRecordingStateResponse = {
  encode(
    message: StartRecordingStateResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.recordingSessionId !== 0) {
      writer.uint32(24).uint64(message.recordingSessionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StartRecordingStateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRecordingStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        case 3:
          message.recordingSessionId = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRecordingStateResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      status: isSet(object.status)
        ? startRecordingStateResponse_StatusFromJSON(object.status)
        : 0,
      recordingSessionId: isSet(object.recordingSessionId)
        ? Number(object.recordingSessionId)
        : 0,
    };
  },

  toJSON(message: StartRecordingStateResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    message.status !== undefined &&
      (obj.status = startRecordingStateResponse_StatusToJSON(message.status));
    message.recordingSessionId !== undefined &&
      (obj.recordingSessionId = Math.round(message.recordingSessionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRecordingStateResponse>, I>>(
    object: I
  ): StartRecordingStateResponse {
    const message = createBaseStartRecordingStateResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.status = object.status ?? 0;
    message.recordingSessionId = object.recordingSessionId ?? 0;
    return message;
  },
};

function createBaseStopRecordingStateRequest(): StopRecordingStateRequest {
  return { header: undefined };
}

export const StopRecordingStateRequest = {
  encode(
    message: StopRecordingStateRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StopRecordingStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopRecordingStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StopRecordingStateRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
    };
  },

  toJSON(message: StopRecordingStateRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StopRecordingStateRequest>, I>>(
    object: I
  ): StopRecordingStateRequest {
    const message = createBaseStopRecordingStateRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    return message;
  },
};

function createBaseStopRecordingStateResponse(): StopRecordingStateResponse {
  return { header: undefined };
}

export const StopRecordingStateResponse = {
  encode(
    message: StopRecordingStateResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StopRecordingStateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopRecordingStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StopRecordingStateResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
    };
  },

  toJSON(message: StopRecordingStateResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StopRecordingStateResponse>, I>>(
    object: I
  ): StopRecordingStateResponse {
    const message = createBaseStopRecordingStateResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    return message;
  },
};

function createBaseDownloadRobotStateLogRequest(): DownloadRobotStateLogRequest {
  return { header: undefined, logType: 0 };
}

export const DownloadRobotStateLogRequest = {
  encode(
    message: DownloadRobotStateLogRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.logType !== 0) {
      writer.uint32(16).int32(message.logType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DownloadRobotStateLogRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadRobotStateLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = RequestHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.logType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DownloadRobotStateLogRequest {
    return {
      header: isSet(object.header)
        ? RequestHeader.fromJSON(object.header)
        : undefined,
      logType: isSet(object.logType)
        ? downloadRobotStateLogRequest_LogTypeFromJSON(object.logType)
        : 0,
    };
  },

  toJSON(message: DownloadRobotStateLogRequest): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? RequestHeader.toJSON(message.header)
        : undefined);
    message.logType !== undefined &&
      (obj.logType = downloadRobotStateLogRequest_LogTypeToJSON(
        message.logType
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DownloadRobotStateLogRequest>, I>>(
    object: I
  ): DownloadRobotStateLogRequest {
    const message = createBaseDownloadRobotStateLogRequest();
    message.header =
      object.header !== undefined && object.header !== null
        ? RequestHeader.fromPartial(object.header)
        : undefined;
    message.logType = object.logType ?? 0;
    return message;
  },
};

function createBaseLoggedJoints(): LoggedJoints {
  return {
    fl: undefined,
    fr: undefined,
    hl: undefined,
    hr: undefined,
    arm: undefined,
    gripperAngle: undefined,
  };
}

export const LoggedJoints = {
  encode(
    message: LoggedJoints,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.fl !== undefined) {
      LegJointAngles.encode(message.fl, writer.uint32(10).fork()).ldelim();
    }
    if (message.fr !== undefined) {
      LegJointAngles.encode(message.fr, writer.uint32(18).fork()).ldelim();
    }
    if (message.hl !== undefined) {
      LegJointAngles.encode(message.hl, writer.uint32(26).fork()).ldelim();
    }
    if (message.hr !== undefined) {
      LegJointAngles.encode(message.hr, writer.uint32(34).fork()).ldelim();
    }
    if (message.arm !== undefined) {
      ArmJointAngles.encode(message.arm, writer.uint32(42).fork()).ldelim();
    }
    if (message.gripperAngle !== undefined) {
      DoubleValue.encode(
        { value: message.gripperAngle! },
        writer.uint32(50).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoggedJoints {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedJoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fl = LegJointAngles.decode(reader, reader.uint32());
          break;
        case 2:
          message.fr = LegJointAngles.decode(reader, reader.uint32());
          break;
        case 3:
          message.hl = LegJointAngles.decode(reader, reader.uint32());
          break;
        case 4:
          message.hr = LegJointAngles.decode(reader, reader.uint32());
          break;
        case 5:
          message.arm = ArmJointAngles.decode(reader, reader.uint32());
          break;
        case 6:
          message.gripperAngle = DoubleValue.decode(
            reader,
            reader.uint32()
          ).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LoggedJoints {
    return {
      fl: isSet(object.fl) ? LegJointAngles.fromJSON(object.fl) : undefined,
      fr: isSet(object.fr) ? LegJointAngles.fromJSON(object.fr) : undefined,
      hl: isSet(object.hl) ? LegJointAngles.fromJSON(object.hl) : undefined,
      hr: isSet(object.hr) ? LegJointAngles.fromJSON(object.hr) : undefined,
      arm: isSet(object.arm) ? ArmJointAngles.fromJSON(object.arm) : undefined,
      gripperAngle: isSet(object.gripperAngle)
        ? Number(object.gripperAngle)
        : undefined,
    };
  },

  toJSON(message: LoggedJoints): unknown {
    const obj: any = {};
    message.fl !== undefined &&
      (obj.fl = message.fl ? LegJointAngles.toJSON(message.fl) : undefined);
    message.fr !== undefined &&
      (obj.fr = message.fr ? LegJointAngles.toJSON(message.fr) : undefined);
    message.hl !== undefined &&
      (obj.hl = message.hl ? LegJointAngles.toJSON(message.hl) : undefined);
    message.hr !== undefined &&
      (obj.hr = message.hr ? LegJointAngles.toJSON(message.hr) : undefined);
    message.arm !== undefined &&
      (obj.arm = message.arm ? ArmJointAngles.toJSON(message.arm) : undefined);
    message.gripperAngle !== undefined &&
      (obj.gripperAngle = message.gripperAngle);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LoggedJoints>, I>>(
    object: I
  ): LoggedJoints {
    const message = createBaseLoggedJoints();
    message.fl =
      object.fl !== undefined && object.fl !== null
        ? LegJointAngles.fromPartial(object.fl)
        : undefined;
    message.fr =
      object.fr !== undefined && object.fr !== null
        ? LegJointAngles.fromPartial(object.fr)
        : undefined;
    message.hl =
      object.hl !== undefined && object.hl !== null
        ? LegJointAngles.fromPartial(object.hl)
        : undefined;
    message.hr =
      object.hr !== undefined && object.hr !== null
        ? LegJointAngles.fromPartial(object.hr)
        : undefined;
    message.arm =
      object.arm !== undefined && object.arm !== null
        ? ArmJointAngles.fromPartial(object.arm)
        : undefined;
    message.gripperAngle = object.gripperAngle ?? undefined;
    return message;
  },
};

function createBaseLoggedFootContacts(): LoggedFootContacts {
  return {
    frContact: false,
    flContact: false,
    hrContact: false,
    hlContact: false,
  };
}

export const LoggedFootContacts = {
  encode(
    message: LoggedFootContacts,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.frContact === true) {
      writer.uint32(8).bool(message.frContact);
    }
    if (message.flContact === true) {
      writer.uint32(16).bool(message.flContact);
    }
    if (message.hrContact === true) {
      writer.uint32(24).bool(message.hrContact);
    }
    if (message.hlContact === true) {
      writer.uint32(32).bool(message.hlContact);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoggedFootContacts {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedFootContacts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.frContact = reader.bool();
          break;
        case 2:
          message.flContact = reader.bool();
          break;
        case 3:
          message.hrContact = reader.bool();
          break;
        case 4:
          message.hlContact = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LoggedFootContacts {
    return {
      frContact: isSet(object.frContact) ? Boolean(object.frContact) : false,
      flContact: isSet(object.flContact) ? Boolean(object.flContact) : false,
      hrContact: isSet(object.hrContact) ? Boolean(object.hrContact) : false,
      hlContact: isSet(object.hlContact) ? Boolean(object.hlContact) : false,
    };
  },

  toJSON(message: LoggedFootContacts): unknown {
    const obj: any = {};
    message.frContact !== undefined && (obj.frContact = message.frContact);
    message.flContact !== undefined && (obj.flContact = message.flContact);
    message.hrContact !== undefined && (obj.hrContact = message.hrContact);
    message.hlContact !== undefined && (obj.hlContact = message.hlContact);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LoggedFootContacts>, I>>(
    object: I
  ): LoggedFootContacts {
    const message = createBaseLoggedFootContacts();
    message.frContact = object.frContact ?? false;
    message.flContact = object.flContact ?? false;
    message.hrContact = object.hrContact ?? false;
    message.hlContact = object.hlContact ?? false;
    return message;
  },
};

function createBaseLoggedStateKeyFrame(): LoggedStateKeyFrame {
  return {
    jointAngles: undefined,
    footContactState: undefined,
    animationTformBody: undefined,
    timestamp: undefined,
  };
}

export const LoggedStateKeyFrame = {
  encode(
    message: LoggedStateKeyFrame,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.jointAngles !== undefined) {
      LoggedJoints.encode(
        message.jointAngles,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.footContactState !== undefined) {
      LoggedFootContacts.encode(
        message.footContactState,
        writer.uint32(34).fork()
      ).ldelim();
    }
    if (message.animationTformBody !== undefined) {
      SE3Pose.encode(
        message.animationTformBody,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(
        toTimestamp(message.timestamp),
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoggedStateKeyFrame {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedStateKeyFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.jointAngles = LoggedJoints.decode(reader, reader.uint32());
          break;
        case 4:
          message.footContactState = LoggedFootContacts.decode(
            reader,
            reader.uint32()
          );
          break;
        case 2:
          message.animationTformBody = SE3Pose.decode(reader, reader.uint32());
          break;
        case 3:
          message.timestamp = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LoggedStateKeyFrame {
    return {
      jointAngles: isSet(object.jointAngles)
        ? LoggedJoints.fromJSON(object.jointAngles)
        : undefined,
      footContactState: isSet(object.footContactState)
        ? LoggedFootContacts.fromJSON(object.footContactState)
        : undefined,
      animationTformBody: isSet(object.animationTformBody)
        ? SE3Pose.fromJSON(object.animationTformBody)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? fromJsonTimestamp(object.timestamp)
        : undefined,
    };
  },

  toJSON(message: LoggedStateKeyFrame): unknown {
    const obj: any = {};
    message.jointAngles !== undefined &&
      (obj.jointAngles = message.jointAngles
        ? LoggedJoints.toJSON(message.jointAngles)
        : undefined);
    message.footContactState !== undefined &&
      (obj.footContactState = message.footContactState
        ? LoggedFootContacts.toJSON(message.footContactState)
        : undefined);
    message.animationTformBody !== undefined &&
      (obj.animationTformBody = message.animationTformBody
        ? SE3Pose.toJSON(message.animationTformBody)
        : undefined);
    message.timestamp !== undefined &&
      (obj.timestamp = message.timestamp.toISOString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LoggedStateKeyFrame>, I>>(
    object: I
  ): LoggedStateKeyFrame {
    const message = createBaseLoggedStateKeyFrame();
    message.jointAngles =
      object.jointAngles !== undefined && object.jointAngles !== null
        ? LoggedJoints.fromPartial(object.jointAngles)
        : undefined;
    message.footContactState =
      object.footContactState !== undefined && object.footContactState !== null
        ? LoggedFootContacts.fromPartial(object.footContactState)
        : undefined;
    message.animationTformBody =
      object.animationTformBody !== undefined &&
      object.animationTformBody !== null
        ? SE3Pose.fromPartial(object.animationTformBody)
        : undefined;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseChoreographyStateLog(): ChoreographyStateLog {
  return { keyFrames: [] };
}

export const ChoreographyStateLog = {
  encode(
    message: ChoreographyStateLog,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.keyFrames) {
      LoggedStateKeyFrame.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChoreographyStateLog {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoreographyStateLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keyFrames.push(
            LoggedStateKeyFrame.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChoreographyStateLog {
    return {
      keyFrames: Array.isArray(object?.keyFrames)
        ? object.keyFrames.map((e: any) => LoggedStateKeyFrame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChoreographyStateLog): unknown {
    const obj: any = {};
    if (message.keyFrames) {
      obj.keyFrames = message.keyFrames.map((e) =>
        e ? LoggedStateKeyFrame.toJSON(e) : undefined
      );
    } else {
      obj.keyFrames = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChoreographyStateLog>, I>>(
    object: I
  ): ChoreographyStateLog {
    const message = createBaseChoreographyStateLog();
    message.keyFrames =
      object.keyFrames?.map((e) => LoggedStateKeyFrame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDownloadRobotStateLogResponse(): DownloadRobotStateLogResponse {
  return { header: undefined, status: 0, chunk: undefined };
}

export const DownloadRobotStateLogResponse = {
  encode(
    message: DownloadRobotStateLogResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.header !== undefined) {
      ResponseHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.chunk !== undefined) {
      DataChunk.encode(message.chunk, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DownloadRobotStateLogResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadRobotStateLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = ResponseHeader.decode(reader, reader.uint32());
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        case 3:
          message.chunk = DataChunk.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DownloadRobotStateLogResponse {
    return {
      header: isSet(object.header)
        ? ResponseHeader.fromJSON(object.header)
        : undefined,
      status: isSet(object.status)
        ? downloadRobotStateLogResponse_StatusFromJSON(object.status)
        : 0,
      chunk: isSet(object.chunk) ? DataChunk.fromJSON(object.chunk) : undefined,
    };
  },

  toJSON(message: DownloadRobotStateLogResponse): unknown {
    const obj: any = {};
    message.header !== undefined &&
      (obj.header = message.header
        ? ResponseHeader.toJSON(message.header)
        : undefined);
    message.status !== undefined &&
      (obj.status = downloadRobotStateLogResponse_StatusToJSON(message.status));
    message.chunk !== undefined &&
      (obj.chunk = message.chunk ? DataChunk.toJSON(message.chunk) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DownloadRobotStateLogResponse>, I>>(
    object: I
  ): DownloadRobotStateLogResponse {
    const message = createBaseDownloadRobotStateLogResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? ResponseHeader.fromPartial(object.header)
        : undefined;
    message.status = object.status ?? 0;
    message.chunk =
      object.chunk !== undefined && object.chunk !== null
        ? DataChunk.fromPartial(object.chunk)
        : undefined;
    return message;
  },
};

function createBaseMoveParams(): MoveParams {
  return {
    type: "",
    startSlice: 0,
    requestedSlices: 0,
    jumpParams: undefined,
    rotateBodyParams: undefined,
    stepParams: undefined,
    buttCircleParams: undefined,
    turnParams: undefined,
    pace2stepParams: undefined,
    twerkParams: undefined,
    chickenHeadParams: undefined,
    clapParams: undefined,
    frontUpParams: undefined,
    swayParams: undefined,
    bodyHoldParams: undefined,
    armMoveParams: undefined,
    kneelLegMoveParams: undefined,
    runningManParams: undefined,
    kneelCircleParams: undefined,
    gripperParams: undefined,
    hopParams: undefined,
    randomRotateParams: undefined,
    crawlParams: undefined,
    sideParams: undefined,
    bourreeParams: undefined,
    workspaceArmMoveParams: undefined,
    figure8Params: undefined,
    kneelLegMove2Params: undefined,
    fidgetStandParams: undefined,
    gotoParams: undefined,
    frameSnapshotParams: undefined,
    setColorParams: undefined,
    rippleColorParams: undefined,
    fadeColorParams: undefined,
    independentColorParams: undefined,
    animateParams: undefined,
  };
}

export const MoveParams = {
  encode(
    message: MoveParams,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.startSlice !== 0) {
      writer.uint32(16).int32(message.startSlice);
    }
    if (message.requestedSlices !== 0) {
      writer.uint32(24).int32(message.requestedSlices);
    }
    if (message.jumpParams !== undefined) {
      JumpParams.encode(message.jumpParams, writer.uint32(90).fork()).ldelim();
    }
    if (message.rotateBodyParams !== undefined) {
      RotateBodyParams.encode(
        message.rotateBodyParams,
        writer.uint32(98).fork()
      ).ldelim();
    }
    if (message.stepParams !== undefined) {
      StepParams.encode(message.stepParams, writer.uint32(106).fork()).ldelim();
    }
    if (message.buttCircleParams !== undefined) {
      ButtCircleParams.encode(
        message.buttCircleParams,
        writer.uint32(114).fork()
      ).ldelim();
    }
    if (message.turnParams !== undefined) {
      TurnParams.encode(message.turnParams, writer.uint32(122).fork()).ldelim();
    }
    if (message.pace2stepParams !== undefined) {
      Pace2StepParams.encode(
        message.pace2stepParams,
        writer.uint32(130).fork()
      ).ldelim();
    }
    if (message.twerkParams !== undefined) {
      TwerkParams.encode(
        message.twerkParams,
        writer.uint32(138).fork()
      ).ldelim();
    }
    if (message.chickenHeadParams !== undefined) {
      ChickenHeadParams.encode(
        message.chickenHeadParams,
        writer.uint32(146).fork()
      ).ldelim();
    }
    if (message.clapParams !== undefined) {
      ClapParams.encode(message.clapParams, writer.uint32(154).fork()).ldelim();
    }
    if (message.frontUpParams !== undefined) {
      FrontUpParams.encode(
        message.frontUpParams,
        writer.uint32(162).fork()
      ).ldelim();
    }
    if (message.swayParams !== undefined) {
      SwayParams.encode(message.swayParams, writer.uint32(170).fork()).ldelim();
    }
    if (message.bodyHoldParams !== undefined) {
      BodyHoldParams.encode(
        message.bodyHoldParams,
        writer.uint32(178).fork()
      ).ldelim();
    }
    if (message.armMoveParams !== undefined) {
      ArmMoveParams.encode(
        message.armMoveParams,
        writer.uint32(186).fork()
      ).ldelim();
    }
    if (message.kneelLegMoveParams !== undefined) {
      KneelLegMoveParams.encode(
        message.kneelLegMoveParams,
        writer.uint32(194).fork()
      ).ldelim();
    }
    if (message.runningManParams !== undefined) {
      RunningManParams.encode(
        message.runningManParams,
        writer.uint32(202).fork()
      ).ldelim();
    }
    if (message.kneelCircleParams !== undefined) {
      KneelCircleParams.encode(
        message.kneelCircleParams,
        writer.uint32(210).fork()
      ).ldelim();
    }
    if (message.gripperParams !== undefined) {
      GripperParams.encode(
        message.gripperParams,
        writer.uint32(218).fork()
      ).ldelim();
    }
    if (message.hopParams !== undefined) {
      HopParams.encode(message.hopParams, writer.uint32(226).fork()).ldelim();
    }
    if (message.randomRotateParams !== undefined) {
      RandomRotateParams.encode(
        message.randomRotateParams,
        writer.uint32(234).fork()
      ).ldelim();
    }
    if (message.crawlParams !== undefined) {
      CrawlParams.encode(
        message.crawlParams,
        writer.uint32(242).fork()
      ).ldelim();
    }
    if (message.sideParams !== undefined) {
      SideParams.encode(message.sideParams, writer.uint32(250).fork()).ldelim();
    }
    if (message.bourreeParams !== undefined) {
      BourreeParams.encode(
        message.bourreeParams,
        writer.uint32(258).fork()
      ).ldelim();
    }
    if (message.workspaceArmMoveParams !== undefined) {
      WorkspaceArmMoveParams.encode(
        message.workspaceArmMoveParams,
        writer.uint32(266).fork()
      ).ldelim();
    }
    if (message.figure8Params !== undefined) {
      Figure8Params.encode(
        message.figure8Params,
        writer.uint32(274).fork()
      ).ldelim();
    }
    if (message.kneelLegMove2Params !== undefined) {
      KneelLegMove2Params.encode(
        message.kneelLegMove2Params,
        writer.uint32(282).fork()
      ).ldelim();
    }
    if (message.fidgetStandParams !== undefined) {
      FidgetStandParams.encode(
        message.fidgetStandParams,
        writer.uint32(290).fork()
      ).ldelim();
    }
    if (message.gotoParams !== undefined) {
      GotoParams.encode(message.gotoParams, writer.uint32(298).fork()).ldelim();
    }
    if (message.frameSnapshotParams !== undefined) {
      FrameSnapshotParams.encode(
        message.frameSnapshotParams,
        writer.uint32(306).fork()
      ).ldelim();
    }
    if (message.setColorParams !== undefined) {
      SetColorParams.encode(
        message.setColorParams,
        writer.uint32(314).fork()
      ).ldelim();
    }
    if (message.rippleColorParams !== undefined) {
      RippleColorParams.encode(
        message.rippleColorParams,
        writer.uint32(322).fork()
      ).ldelim();
    }
    if (message.fadeColorParams !== undefined) {
      FadeColorParams.encode(
        message.fadeColorParams,
        writer.uint32(330).fork()
      ).ldelim();
    }
    if (message.independentColorParams !== undefined) {
      IndependentColorParams.encode(
        message.independentColorParams,
        writer.uint32(338).fork()
      ).ldelim();
    }
    if (message.animateParams !== undefined) {
      AnimateParams.encode(
        message.animateParams,
        writer.uint32(8002).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MoveParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          message.startSlice = reader.int32();
          break;
        case 3:
          message.requestedSlices = reader.int32();
          break;
        case 11:
          message.jumpParams = JumpParams.decode(reader, reader.uint32());
          break;
        case 12:
          message.rotateBodyParams = RotateBodyParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 13:
          message.stepParams = StepParams.decode(reader, reader.uint32());
          break;
        case 14:
          message.buttCircleParams = ButtCircleParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 15:
          message.turnParams = TurnParams.decode(reader, reader.uint32());
          break;
        case 16:
          message.pace2stepParams = Pace2StepParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 17:
          message.twerkParams = TwerkParams.decode(reader, reader.uint32());
          break;
        case 18:
          message.chickenHeadParams = ChickenHeadParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 19:
          message.clapParams = ClapParams.decode(reader, reader.uint32());
          break;
        case 20:
          message.frontUpParams = FrontUpParams.decode(reader, reader.uint32());
          break;
        case 21:
          message.swayParams = SwayParams.decode(reader, reader.uint32());
          break;
        case 22:
          message.bodyHoldParams = BodyHoldParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 23:
          message.armMoveParams = ArmMoveParams.decode(reader, reader.uint32());
          break;
        case 24:
          message.kneelLegMoveParams = KneelLegMoveParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 25:
          message.runningManParams = RunningManParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 26:
          message.kneelCircleParams = KneelCircleParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 27:
          message.gripperParams = GripperParams.decode(reader, reader.uint32());
          break;
        case 28:
          message.hopParams = HopParams.decode(reader, reader.uint32());
          break;
        case 29:
          message.randomRotateParams = RandomRotateParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 30:
          message.crawlParams = CrawlParams.decode(reader, reader.uint32());
          break;
        case 31:
          message.sideParams = SideParams.decode(reader, reader.uint32());
          break;
        case 32:
          message.bourreeParams = BourreeParams.decode(reader, reader.uint32());
          break;
        case 33:
          message.workspaceArmMoveParams = WorkspaceArmMoveParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 34:
          message.figure8Params = Figure8Params.decode(reader, reader.uint32());
          break;
        case 35:
          message.kneelLegMove2Params = KneelLegMove2Params.decode(
            reader,
            reader.uint32()
          );
          break;
        case 36:
          message.fidgetStandParams = FidgetStandParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 37:
          message.gotoParams = GotoParams.decode(reader, reader.uint32());
          break;
        case 38:
          message.frameSnapshotParams = FrameSnapshotParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 39:
          message.setColorParams = SetColorParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 40:
          message.rippleColorParams = RippleColorParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 41:
          message.fadeColorParams = FadeColorParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 42:
          message.independentColorParams = IndependentColorParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 1000:
          message.animateParams = AnimateParams.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MoveParams {
    return {
      type: isSet(object.type) ? String(object.type) : "",
      startSlice: isSet(object.startSlice) ? Number(object.startSlice) : 0,
      requestedSlices: isSet(object.requestedSlices)
        ? Number(object.requestedSlices)
        : 0,
      jumpParams: isSet(object.jumpParams)
        ? JumpParams.fromJSON(object.jumpParams)
        : undefined,
      rotateBodyParams: isSet(object.rotateBodyParams)
        ? RotateBodyParams.fromJSON(object.rotateBodyParams)
        : undefined,
      stepParams: isSet(object.stepParams)
        ? StepParams.fromJSON(object.stepParams)
        : undefined,
      buttCircleParams: isSet(object.buttCircleParams)
        ? ButtCircleParams.fromJSON(object.buttCircleParams)
        : undefined,
      turnParams: isSet(object.turnParams)
        ? TurnParams.fromJSON(object.turnParams)
        : undefined,
      pace2stepParams: isSet(object.pace2stepParams)
        ? Pace2StepParams.fromJSON(object.pace2stepParams)
        : undefined,
      twerkParams: isSet(object.twerkParams)
        ? TwerkParams.fromJSON(object.twerkParams)
        : undefined,
      chickenHeadParams: isSet(object.chickenHeadParams)
        ? ChickenHeadParams.fromJSON(object.chickenHeadParams)
        : undefined,
      clapParams: isSet(object.clapParams)
        ? ClapParams.fromJSON(object.clapParams)
        : undefined,
      frontUpParams: isSet(object.frontUpParams)
        ? FrontUpParams.fromJSON(object.frontUpParams)
        : undefined,
      swayParams: isSet(object.swayParams)
        ? SwayParams.fromJSON(object.swayParams)
        : undefined,
      bodyHoldParams: isSet(object.bodyHoldParams)
        ? BodyHoldParams.fromJSON(object.bodyHoldParams)
        : undefined,
      armMoveParams: isSet(object.armMoveParams)
        ? ArmMoveParams.fromJSON(object.armMoveParams)
        : undefined,
      kneelLegMoveParams: isSet(object.kneelLegMoveParams)
        ? KneelLegMoveParams.fromJSON(object.kneelLegMoveParams)
        : undefined,
      runningManParams: isSet(object.runningManParams)
        ? RunningManParams.fromJSON(object.runningManParams)
        : undefined,
      kneelCircleParams: isSet(object.kneelCircleParams)
        ? KneelCircleParams.fromJSON(object.kneelCircleParams)
        : undefined,
      gripperParams: isSet(object.gripperParams)
        ? GripperParams.fromJSON(object.gripperParams)
        : undefined,
      hopParams: isSet(object.hopParams)
        ? HopParams.fromJSON(object.hopParams)
        : undefined,
      randomRotateParams: isSet(object.randomRotateParams)
        ? RandomRotateParams.fromJSON(object.randomRotateParams)
        : undefined,
      crawlParams: isSet(object.crawlParams)
        ? CrawlParams.fromJSON(object.crawlParams)
        : undefined,
      sideParams: isSet(object.sideParams)
        ? SideParams.fromJSON(object.sideParams)
        : undefined,
      bourreeParams: isSet(object.bourreeParams)
        ? BourreeParams.fromJSON(object.bourreeParams)
        : undefined,
      workspaceArmMoveParams: isSet(object.workspaceArmMoveParams)
        ? WorkspaceArmMoveParams.fromJSON(object.workspaceArmMoveParams)
        : undefined,
      figure8Params: isSet(object.figure8Params)
        ? Figure8Params.fromJSON(object.figure8Params)
        : undefined,
      kneelLegMove2Params: isSet(object.kneelLegMove2Params)
        ? KneelLegMove2Params.fromJSON(object.kneelLegMove2Params)
        : undefined,
      fidgetStandParams: isSet(object.fidgetStandParams)
        ? FidgetStandParams.fromJSON(object.fidgetStandParams)
        : undefined,
      gotoParams: isSet(object.gotoParams)
        ? GotoParams.fromJSON(object.gotoParams)
        : undefined,
      frameSnapshotParams: isSet(object.frameSnapshotParams)
        ? FrameSnapshotParams.fromJSON(object.frameSnapshotParams)
        : undefined,
      setColorParams: isSet(object.setColorParams)
        ? SetColorParams.fromJSON(object.setColorParams)
        : undefined,
      rippleColorParams: isSet(object.rippleColorParams)
        ? RippleColorParams.fromJSON(object.rippleColorParams)
        : undefined,
      fadeColorParams: isSet(object.fadeColorParams)
        ? FadeColorParams.fromJSON(object.fadeColorParams)
        : undefined,
      independentColorParams: isSet(object.independentColorParams)
        ? IndependentColorParams.fromJSON(object.independentColorParams)
        : undefined,
      animateParams: isSet(object.animateParams)
        ? AnimateParams.fromJSON(object.animateParams)
        : undefined,
    };
  },

  toJSON(message: MoveParams): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = message.type);
    message.startSlice !== undefined &&
      (obj.startSlice = Math.round(message.startSlice));
    message.requestedSlices !== undefined &&
      (obj.requestedSlices = Math.round(message.requestedSlices));
    message.jumpParams !== undefined &&
      (obj.jumpParams = message.jumpParams
        ? JumpParams.toJSON(message.jumpParams)
        : undefined);
    message.rotateBodyParams !== undefined &&
      (obj.rotateBodyParams = message.rotateBodyParams
        ? RotateBodyParams.toJSON(message.rotateBodyParams)
        : undefined);
    message.stepParams !== undefined &&
      (obj.stepParams = message.stepParams
        ? StepParams.toJSON(message.stepParams)
        : undefined);
    message.buttCircleParams !== undefined &&
      (obj.buttCircleParams = message.buttCircleParams
        ? ButtCircleParams.toJSON(message.buttCircleParams)
        : undefined);
    message.turnParams !== undefined &&
      (obj.turnParams = message.turnParams
        ? TurnParams.toJSON(message.turnParams)
        : undefined);
    message.pace2stepParams !== undefined &&
      (obj.pace2stepParams = message.pace2stepParams
        ? Pace2StepParams.toJSON(message.pace2stepParams)
        : undefined);
    message.twerkParams !== undefined &&
      (obj.twerkParams = message.twerkParams
        ? TwerkParams.toJSON(message.twerkParams)
        : undefined);
    message.chickenHeadParams !== undefined &&
      (obj.chickenHeadParams = message.chickenHeadParams
        ? ChickenHeadParams.toJSON(message.chickenHeadParams)
        : undefined);
    message.clapParams !== undefined &&
      (obj.clapParams = message.clapParams
        ? ClapParams.toJSON(message.clapParams)
        : undefined);
    message.frontUpParams !== undefined &&
      (obj.frontUpParams = message.frontUpParams
        ? FrontUpParams.toJSON(message.frontUpParams)
        : undefined);
    message.swayParams !== undefined &&
      (obj.swayParams = message.swayParams
        ? SwayParams.toJSON(message.swayParams)
        : undefined);
    message.bodyHoldParams !== undefined &&
      (obj.bodyHoldParams = message.bodyHoldParams
        ? BodyHoldParams.toJSON(message.bodyHoldParams)
        : undefined);
    message.armMoveParams !== undefined &&
      (obj.armMoveParams = message.armMoveParams
        ? ArmMoveParams.toJSON(message.armMoveParams)
        : undefined);
    message.kneelLegMoveParams !== undefined &&
      (obj.kneelLegMoveParams = message.kneelLegMoveParams
        ? KneelLegMoveParams.toJSON(message.kneelLegMoveParams)
        : undefined);
    message.runningManParams !== undefined &&
      (obj.runningManParams = message.runningManParams
        ? RunningManParams.toJSON(message.runningManParams)
        : undefined);
    message.kneelCircleParams !== undefined &&
      (obj.kneelCircleParams = message.kneelCircleParams
        ? KneelCircleParams.toJSON(message.kneelCircleParams)
        : undefined);
    message.gripperParams !== undefined &&
      (obj.gripperParams = message.gripperParams
        ? GripperParams.toJSON(message.gripperParams)
        : undefined);
    message.hopParams !== undefined &&
      (obj.hopParams = message.hopParams
        ? HopParams.toJSON(message.hopParams)
        : undefined);
    message.randomRotateParams !== undefined &&
      (obj.randomRotateParams = message.randomRotateParams
        ? RandomRotateParams.toJSON(message.randomRotateParams)
        : undefined);
    message.crawlParams !== undefined &&
      (obj.crawlParams = message.crawlParams
        ? CrawlParams.toJSON(message.crawlParams)
        : undefined);
    message.sideParams !== undefined &&
      (obj.sideParams = message.sideParams
        ? SideParams.toJSON(message.sideParams)
        : undefined);
    message.bourreeParams !== undefined &&
      (obj.bourreeParams = message.bourreeParams
        ? BourreeParams.toJSON(message.bourreeParams)
        : undefined);
    message.workspaceArmMoveParams !== undefined &&
      (obj.workspaceArmMoveParams = message.workspaceArmMoveParams
        ? WorkspaceArmMoveParams.toJSON(message.workspaceArmMoveParams)
        : undefined);
    message.figure8Params !== undefined &&
      (obj.figure8Params = message.figure8Params
        ? Figure8Params.toJSON(message.figure8Params)
        : undefined);
    message.kneelLegMove2Params !== undefined &&
      (obj.kneelLegMove2Params = message.kneelLegMove2Params
        ? KneelLegMove2Params.toJSON(message.kneelLegMove2Params)
        : undefined);
    message.fidgetStandParams !== undefined &&
      (obj.fidgetStandParams = message.fidgetStandParams
        ? FidgetStandParams.toJSON(message.fidgetStandParams)
        : undefined);
    message.gotoParams !== undefined &&
      (obj.gotoParams = message.gotoParams
        ? GotoParams.toJSON(message.gotoParams)
        : undefined);
    message.frameSnapshotParams !== undefined &&
      (obj.frameSnapshotParams = message.frameSnapshotParams
        ? FrameSnapshotParams.toJSON(message.frameSnapshotParams)
        : undefined);
    message.setColorParams !== undefined &&
      (obj.setColorParams = message.setColorParams
        ? SetColorParams.toJSON(message.setColorParams)
        : undefined);
    message.rippleColorParams !== undefined &&
      (obj.rippleColorParams = message.rippleColorParams
        ? RippleColorParams.toJSON(message.rippleColorParams)
        : undefined);
    message.fadeColorParams !== undefined &&
      (obj.fadeColorParams = message.fadeColorParams
        ? FadeColorParams.toJSON(message.fadeColorParams)
        : undefined);
    message.independentColorParams !== undefined &&
      (obj.independentColorParams = message.independentColorParams
        ? IndependentColorParams.toJSON(message.independentColorParams)
        : undefined);
    message.animateParams !== undefined &&
      (obj.animateParams = message.animateParams
        ? AnimateParams.toJSON(message.animateParams)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MoveParams>, I>>(
    object: I
  ): MoveParams {
    const message = createBaseMoveParams();
    message.type = object.type ?? "";
    message.startSlice = object.startSlice ?? 0;
    message.requestedSlices = object.requestedSlices ?? 0;
    message.jumpParams =
      object.jumpParams !== undefined && object.jumpParams !== null
        ? JumpParams.fromPartial(object.jumpParams)
        : undefined;
    message.rotateBodyParams =
      object.rotateBodyParams !== undefined && object.rotateBodyParams !== null
        ? RotateBodyParams.fromPartial(object.rotateBodyParams)
        : undefined;
    message.stepParams =
      object.stepParams !== undefined && object.stepParams !== null
        ? StepParams.fromPartial(object.stepParams)
        : undefined;
    message.buttCircleParams =
      object.buttCircleParams !== undefined && object.buttCircleParams !== null
        ? ButtCircleParams.fromPartial(object.buttCircleParams)
        : undefined;
    message.turnParams =
      object.turnParams !== undefined && object.turnParams !== null
        ? TurnParams.fromPartial(object.turnParams)
        : undefined;
    message.pace2stepParams =
      object.pace2stepParams !== undefined && object.pace2stepParams !== null
        ? Pace2StepParams.fromPartial(object.pace2stepParams)
        : undefined;
    message.twerkParams =
      object.twerkParams !== undefined && object.twerkParams !== null
        ? TwerkParams.fromPartial(object.twerkParams)
        : undefined;
    message.chickenHeadParams =
      object.chickenHeadParams !== undefined &&
      object.chickenHeadParams !== null
        ? ChickenHeadParams.fromPartial(object.chickenHeadParams)
        : undefined;
    message.clapParams =
      object.clapParams !== undefined && object.clapParams !== null
        ? ClapParams.fromPartial(object.clapParams)
        : undefined;
    message.frontUpParams =
      object.frontUpParams !== undefined && object.frontUpParams !== null
        ? FrontUpParams.fromPartial(object.frontUpParams)
        : undefined;
    message.swayParams =
      object.swayParams !== undefined && object.swayParams !== null
        ? SwayParams.fromPartial(object.swayParams)
        : undefined;
    message.bodyHoldParams =
      object.bodyHoldParams !== undefined && object.bodyHoldParams !== null
        ? BodyHoldParams.fromPartial(object.bodyHoldParams)
        : undefined;
    message.armMoveParams =
      object.armMoveParams !== undefined && object.armMoveParams !== null
        ? ArmMoveParams.fromPartial(object.armMoveParams)
        : undefined;
    message.kneelLegMoveParams =
      object.kneelLegMoveParams !== undefined &&
      object.kneelLegMoveParams !== null
        ? KneelLegMoveParams.fromPartial(object.kneelLegMoveParams)
        : undefined;
    message.runningManParams =
      object.runningManParams !== undefined && object.runningManParams !== null
        ? RunningManParams.fromPartial(object.runningManParams)
        : undefined;
    message.kneelCircleParams =
      object.kneelCircleParams !== undefined &&
      object.kneelCircleParams !== null
        ? KneelCircleParams.fromPartial(object.kneelCircleParams)
        : undefined;
    message.gripperParams =
      object.gripperParams !== undefined && object.gripperParams !== null
        ? GripperParams.fromPartial(object.gripperParams)
        : undefined;
    message.hopParams =
      object.hopParams !== undefined && object.hopParams !== null
        ? HopParams.fromPartial(object.hopParams)
        : undefined;
    message.randomRotateParams =
      object.randomRotateParams !== undefined &&
      object.randomRotateParams !== null
        ? RandomRotateParams.fromPartial(object.randomRotateParams)
        : undefined;
    message.crawlParams =
      object.crawlParams !== undefined && object.crawlParams !== null
        ? CrawlParams.fromPartial(object.crawlParams)
        : undefined;
    message.sideParams =
      object.sideParams !== undefined && object.sideParams !== null
        ? SideParams.fromPartial(object.sideParams)
        : undefined;
    message.bourreeParams =
      object.bourreeParams !== undefined && object.bourreeParams !== null
        ? BourreeParams.fromPartial(object.bourreeParams)
        : undefined;
    message.workspaceArmMoveParams =
      object.workspaceArmMoveParams !== undefined &&
      object.workspaceArmMoveParams !== null
        ? WorkspaceArmMoveParams.fromPartial(object.workspaceArmMoveParams)
        : undefined;
    message.figure8Params =
      object.figure8Params !== undefined && object.figure8Params !== null
        ? Figure8Params.fromPartial(object.figure8Params)
        : undefined;
    message.kneelLegMove2Params =
      object.kneelLegMove2Params !== undefined &&
      object.kneelLegMove2Params !== null
        ? KneelLegMove2Params.fromPartial(object.kneelLegMove2Params)
        : undefined;
    message.fidgetStandParams =
      object.fidgetStandParams !== undefined &&
      object.fidgetStandParams !== null
        ? FidgetStandParams.fromPartial(object.fidgetStandParams)
        : undefined;
    message.gotoParams =
      object.gotoParams !== undefined && object.gotoParams !== null
        ? GotoParams.fromPartial(object.gotoParams)
        : undefined;
    message.frameSnapshotParams =
      object.frameSnapshotParams !== undefined &&
      object.frameSnapshotParams !== null
        ? FrameSnapshotParams.fromPartial(object.frameSnapshotParams)
        : undefined;
    message.setColorParams =
      object.setColorParams !== undefined && object.setColorParams !== null
        ? SetColorParams.fromPartial(object.setColorParams)
        : undefined;
    message.rippleColorParams =
      object.rippleColorParams !== undefined &&
      object.rippleColorParams !== null
        ? RippleColorParams.fromPartial(object.rippleColorParams)
        : undefined;
    message.fadeColorParams =
      object.fadeColorParams !== undefined && object.fadeColorParams !== null
        ? FadeColorParams.fromPartial(object.fadeColorParams)
        : undefined;
    message.independentColorParams =
      object.independentColorParams !== undefined &&
      object.independentColorParams !== null
        ? IndependentColorParams.fromPartial(object.independentColorParams)
        : undefined;
    message.animateParams =
      object.animateParams !== undefined && object.animateParams !== null
        ? AnimateParams.fromPartial(object.animateParams)
        : undefined;
    return message;
  },
};

function createBaseMoveInfo(): MoveInfo {
  return {
    name: "",
    moveLengthSlices: 0,
    moveLengthTime: 0,
    isExtendable: false,
    minMoveLengthSlices: 0,
    maxMoveLengthSlices: 0,
    minTime: 0,
    maxTime: 0,
    entranceStates: [],
    exitState: 0,
    controlsArm: false,
    controlsLegs: false,
    controlsBody: false,
    controlsGripper: false,
    controlsLights: false,
    controlsAnnotations: false,
    display: undefined,
    animatedMoveGeneratedId: undefined,
  };
}

export const MoveInfo = {
  encode(
    message: MoveInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.moveLengthSlices !== 0) {
      writer.uint32(16).int32(message.moveLengthSlices);
    }
    if (message.moveLengthTime !== 0) {
      writer.uint32(121).double(message.moveLengthTime);
    }
    if (message.isExtendable === true) {
      writer.uint32(24).bool(message.isExtendable);
    }
    if (message.minMoveLengthSlices !== 0) {
      writer.uint32(104).int32(message.minMoveLengthSlices);
    }
    if (message.maxMoveLengthSlices !== 0) {
      writer.uint32(112).int32(message.maxMoveLengthSlices);
    }
    if (message.minTime !== 0) {
      writer.uint32(49).double(message.minTime);
    }
    if (message.maxTime !== 0) {
      writer.uint32(57).double(message.maxTime);
    }
    writer.uint32(34).fork();
    for (const v of message.entranceStates) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.exitState !== 0) {
      writer.uint32(40).int32(message.exitState);
    }
    if (message.controlsArm === true) {
      writer.uint32(64).bool(message.controlsArm);
    }
    if (message.controlsLegs === true) {
      writer.uint32(72).bool(message.controlsLegs);
    }
    if (message.controlsBody === true) {
      writer.uint32(80).bool(message.controlsBody);
    }
    if (message.controlsGripper === true) {
      writer.uint32(96).bool(message.controlsGripper);
    }
    if (message.controlsLights === true) {
      writer.uint32(136).bool(message.controlsLights);
    }
    if (message.controlsAnnotations === true) {
      writer.uint32(144).bool(message.controlsAnnotations);
    }
    if (message.display !== undefined) {
      ChoreographerDisplayInfo.encode(
        message.display,
        writer.uint32(90).fork()
      ).ldelim();
    }
    if (message.animatedMoveGeneratedId !== undefined) {
      StringValue.encode(
        { value: message.animatedMoveGeneratedId! },
        writer.uint32(130).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MoveInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.moveLengthSlices = reader.int32();
          break;
        case 15:
          message.moveLengthTime = reader.double();
          break;
        case 3:
          message.isExtendable = reader.bool();
          break;
        case 13:
          message.minMoveLengthSlices = reader.int32();
          break;
        case 14:
          message.maxMoveLengthSlices = reader.int32();
          break;
        case 6:
          message.minTime = reader.double();
          break;
        case 7:
          message.maxTime = reader.double();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.entranceStates.push(reader.int32() as any);
            }
          } else {
            message.entranceStates.push(reader.int32() as any);
          }
          break;
        case 5:
          message.exitState = reader.int32() as any;
          break;
        case 8:
          message.controlsArm = reader.bool();
          break;
        case 9:
          message.controlsLegs = reader.bool();
          break;
        case 10:
          message.controlsBody = reader.bool();
          break;
        case 12:
          message.controlsGripper = reader.bool();
          break;
        case 17:
          message.controlsLights = reader.bool();
          break;
        case 18:
          message.controlsAnnotations = reader.bool();
          break;
        case 11:
          message.display = ChoreographerDisplayInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        case 16:
          message.animatedMoveGeneratedId = StringValue.decode(
            reader,
            reader.uint32()
          ).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MoveInfo {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      moveLengthSlices: isSet(object.moveLengthSlices)
        ? Number(object.moveLengthSlices)
        : 0,
      moveLengthTime: isSet(object.moveLengthTime)
        ? Number(object.moveLengthTime)
        : 0,
      isExtendable: isSet(object.isExtendable)
        ? Boolean(object.isExtendable)
        : false,
      minMoveLengthSlices: isSet(object.minMoveLengthSlices)
        ? Number(object.minMoveLengthSlices)
        : 0,
      maxMoveLengthSlices: isSet(object.maxMoveLengthSlices)
        ? Number(object.maxMoveLengthSlices)
        : 0,
      minTime: isSet(object.minTime) ? Number(object.minTime) : 0,
      maxTime: isSet(object.maxTime) ? Number(object.maxTime) : 0,
      entranceStates: Array.isArray(object?.entranceStates)
        ? object.entranceStates.map((e: any) =>
            moveInfo_TransitionStateFromJSON(e)
          )
        : [],
      exitState: isSet(object.exitState)
        ? moveInfo_TransitionStateFromJSON(object.exitState)
        : 0,
      controlsArm: isSet(object.controlsArm)
        ? Boolean(object.controlsArm)
        : false,
      controlsLegs: isSet(object.controlsLegs)
        ? Boolean(object.controlsLegs)
        : false,
      controlsBody: isSet(object.controlsBody)
        ? Boolean(object.controlsBody)
        : false,
      controlsGripper: isSet(object.controlsGripper)
        ? Boolean(object.controlsGripper)
        : false,
      controlsLights: isSet(object.controlsLights)
        ? Boolean(object.controlsLights)
        : false,
      controlsAnnotations: isSet(object.controlsAnnotations)
        ? Boolean(object.controlsAnnotations)
        : false,
      display: isSet(object.display)
        ? ChoreographerDisplayInfo.fromJSON(object.display)
        : undefined,
      animatedMoveGeneratedId: isSet(object.animatedMoveGeneratedId)
        ? String(object.animatedMoveGeneratedId)
        : undefined,
    };
  },

  toJSON(message: MoveInfo): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.moveLengthSlices !== undefined &&
      (obj.moveLengthSlices = Math.round(message.moveLengthSlices));
    message.moveLengthTime !== undefined &&
      (obj.moveLengthTime = message.moveLengthTime);
    message.isExtendable !== undefined &&
      (obj.isExtendable = message.isExtendable);
    message.minMoveLengthSlices !== undefined &&
      (obj.minMoveLengthSlices = Math.round(message.minMoveLengthSlices));
    message.maxMoveLengthSlices !== undefined &&
      (obj.maxMoveLengthSlices = Math.round(message.maxMoveLengthSlices));
    message.minTime !== undefined && (obj.minTime = message.minTime);
    message.maxTime !== undefined && (obj.maxTime = message.maxTime);
    if (message.entranceStates) {
      obj.entranceStates = message.entranceStates.map((e) =>
        moveInfo_TransitionStateToJSON(e)
      );
    } else {
      obj.entranceStates = [];
    }
    message.exitState !== undefined &&
      (obj.exitState = moveInfo_TransitionStateToJSON(message.exitState));
    message.controlsArm !== undefined &&
      (obj.controlsArm = message.controlsArm);
    message.controlsLegs !== undefined &&
      (obj.controlsLegs = message.controlsLegs);
    message.controlsBody !== undefined &&
      (obj.controlsBody = message.controlsBody);
    message.controlsGripper !== undefined &&
      (obj.controlsGripper = message.controlsGripper);
    message.controlsLights !== undefined &&
      (obj.controlsLights = message.controlsLights);
    message.controlsAnnotations !== undefined &&
      (obj.controlsAnnotations = message.controlsAnnotations);
    message.display !== undefined &&
      (obj.display = message.display
        ? ChoreographerDisplayInfo.toJSON(message.display)
        : undefined);
    message.animatedMoveGeneratedId !== undefined &&
      (obj.animatedMoveGeneratedId = message.animatedMoveGeneratedId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MoveInfo>, I>>(object: I): MoveInfo {
    const message = createBaseMoveInfo();
    message.name = object.name ?? "";
    message.moveLengthSlices = object.moveLengthSlices ?? 0;
    message.moveLengthTime = object.moveLengthTime ?? 0;
    message.isExtendable = object.isExtendable ?? false;
    message.minMoveLengthSlices = object.minMoveLengthSlices ?? 0;
    message.maxMoveLengthSlices = object.maxMoveLengthSlices ?? 0;
    message.minTime = object.minTime ?? 0;
    message.maxTime = object.maxTime ?? 0;
    message.entranceStates = object.entranceStates?.map((e) => e) || [];
    message.exitState = object.exitState ?? 0;
    message.controlsArm = object.controlsArm ?? false;
    message.controlsLegs = object.controlsLegs ?? false;
    message.controlsBody = object.controlsBody ?? false;
    message.controlsGripper = object.controlsGripper ?? false;
    message.controlsLights = object.controlsLights ?? false;
    message.controlsAnnotations = object.controlsAnnotations ?? false;
    message.display =
      object.display !== undefined && object.display !== null
        ? ChoreographerDisplayInfo.fromPartial(object.display)
        : undefined;
    message.animatedMoveGeneratedId =
      object.animatedMoveGeneratedId ?? undefined;
    return message;
  },
};

function createBaseChoreographerDisplayInfo(): ChoreographerDisplayInfo {
  return {
    color: undefined,
    markers: [],
    description: "",
    image: "",
    category: 0,
  };
}

export const ChoreographerDisplayInfo = {
  encode(
    message: ChoreographerDisplayInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.color !== undefined) {
      ChoreographerDisplayInfo_Color.encode(
        message.color,
        writer.uint32(10).fork()
      ).ldelim();
    }
    writer.uint32(106).fork();
    for (const v of message.markers) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.description !== "") {
      writer.uint32(114).string(message.description);
    }
    if (message.image !== "") {
      writer.uint32(122).string(message.image);
    }
    if (message.category !== 0) {
      writer.uint32(128).int32(message.category);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChoreographerDisplayInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoreographerDisplayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.color = ChoreographerDisplayInfo_Color.decode(
            reader,
            reader.uint32()
          );
          break;
        case 13:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.markers.push(reader.int32());
            }
          } else {
            message.markers.push(reader.int32());
          }
          break;
        case 14:
          message.description = reader.string();
          break;
        case 15:
          message.image = reader.string();
          break;
        case 16:
          message.category = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChoreographerDisplayInfo {
    return {
      color: isSet(object.color)
        ? ChoreographerDisplayInfo_Color.fromJSON(object.color)
        : undefined,
      markers: Array.isArray(object?.markers)
        ? object.markers.map((e: any) => Number(e))
        : [],
      description: isSet(object.description) ? String(object.description) : "",
      image: isSet(object.image) ? String(object.image) : "",
      category: isSet(object.category)
        ? choreographerDisplayInfo_CategoryFromJSON(object.category)
        : 0,
    };
  },

  toJSON(message: ChoreographerDisplayInfo): unknown {
    const obj: any = {};
    message.color !== undefined &&
      (obj.color = message.color
        ? ChoreographerDisplayInfo_Color.toJSON(message.color)
        : undefined);
    if (message.markers) {
      obj.markers = message.markers.map((e) => Math.round(e));
    } else {
      obj.markers = [];
    }
    message.description !== undefined &&
      (obj.description = message.description);
    message.image !== undefined && (obj.image = message.image);
    message.category !== undefined &&
      (obj.category = choreographerDisplayInfo_CategoryToJSON(
        message.category
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChoreographerDisplayInfo>, I>>(
    object: I
  ): ChoreographerDisplayInfo {
    const message = createBaseChoreographerDisplayInfo();
    message.color =
      object.color !== undefined && object.color !== null
        ? ChoreographerDisplayInfo_Color.fromPartial(object.color)
        : undefined;
    message.markers = object.markers?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.image = object.image ?? "";
    message.category = object.category ?? 0;
    return message;
  },
};

function createBaseChoreographerDisplayInfo_Color(): ChoreographerDisplayInfo_Color {
  return { r: 0, g: 0, b: 0, a: 0 };
}

export const ChoreographerDisplayInfo_Color = {
  encode(
    message: ChoreographerDisplayInfo_Color,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.r !== 0) {
      writer.uint32(8).int32(message.r);
    }
    if (message.g !== 0) {
      writer.uint32(16).int32(message.g);
    }
    if (message.b !== 0) {
      writer.uint32(24).int32(message.b);
    }
    if (message.a !== 0) {
      writer.uint32(33).double(message.a);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChoreographerDisplayInfo_Color {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoreographerDisplayInfo_Color();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.r = reader.int32();
          break;
        case 2:
          message.g = reader.int32();
          break;
        case 3:
          message.b = reader.int32();
          break;
        case 4:
          message.a = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChoreographerDisplayInfo_Color {
    return {
      r: isSet(object.r) ? Number(object.r) : 0,
      g: isSet(object.g) ? Number(object.g) : 0,
      b: isSet(object.b) ? Number(object.b) : 0,
      a: isSet(object.a) ? Number(object.a) : 0,
    };
  },

  toJSON(message: ChoreographerDisplayInfo_Color): unknown {
    const obj: any = {};
    message.r !== undefined && (obj.r = Math.round(message.r));
    message.g !== undefined && (obj.g = Math.round(message.g));
    message.b !== undefined && (obj.b = Math.round(message.b));
    message.a !== undefined && (obj.a = message.a);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChoreographerDisplayInfo_Color>, I>>(
    object: I
  ): ChoreographerDisplayInfo_Color {
    const message = createBaseChoreographerDisplayInfo_Color();
    message.r = object.r ?? 0;
    message.g = object.g ?? 0;
    message.b = object.b ?? 0;
    message.a = object.a ?? 0;
    return message;
  },
};

function createBaseChoreographySequence(): ChoreographySequence {
  return { name: "", slicesPerMinute: 0, moves: [] };
}

export const ChoreographySequence = {
  encode(
    message: ChoreographySequence,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.slicesPerMinute !== 0) {
      writer.uint32(17).double(message.slicesPerMinute);
    }
    for (const v of message.moves) {
      MoveParams.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChoreographySequence {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoreographySequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.slicesPerMinute = reader.double();
          break;
        case 3:
          message.moves.push(MoveParams.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChoreographySequence {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      slicesPerMinute: isSet(object.slicesPerMinute)
        ? Number(object.slicesPerMinute)
        : 0,
      moves: Array.isArray(object?.moves)
        ? object.moves.map((e: any) => MoveParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChoreographySequence): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.slicesPerMinute !== undefined &&
      (obj.slicesPerMinute = message.slicesPerMinute);
    if (message.moves) {
      obj.moves = message.moves.map((e) =>
        e ? MoveParams.toJSON(e) : undefined
      );
    } else {
      obj.moves = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChoreographySequence>, I>>(
    object: I
  ): ChoreographySequence {
    const message = createBaseChoreographySequence();
    message.name = object.name ?? "";
    message.slicesPerMinute = object.slicesPerMinute ?? 0;
    message.moves = object.moves?.map((e) => MoveParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChoreographerSave(): ChoreographerSave {
  return {
    choreographySequence: undefined,
    musicFile: "",
    musicStartSlice: 0,
    choreographyStartSlice: 0,
  };
}

export const ChoreographerSave = {
  encode(
    message: ChoreographerSave,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.choreographySequence !== undefined) {
      ChoreographySequence.encode(
        message.choreographySequence,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.musicFile !== "") {
      writer.uint32(18).string(message.musicFile);
    }
    if (message.musicStartSlice !== 0) {
      writer.uint32(25).double(message.musicStartSlice);
    }
    if (message.choreographyStartSlice !== 0) {
      writer.uint32(33).double(message.choreographyStartSlice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChoreographerSave {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoreographerSave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.choreographySequence = ChoreographySequence.decode(
            reader,
            reader.uint32()
          );
          break;
        case 2:
          message.musicFile = reader.string();
          break;
        case 3:
          message.musicStartSlice = reader.double();
          break;
        case 4:
          message.choreographyStartSlice = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChoreographerSave {
    return {
      choreographySequence: isSet(object.choreographySequence)
        ? ChoreographySequence.fromJSON(object.choreographySequence)
        : undefined,
      musicFile: isSet(object.musicFile) ? String(object.musicFile) : "",
      musicStartSlice: isSet(object.musicStartSlice)
        ? Number(object.musicStartSlice)
        : 0,
      choreographyStartSlice: isSet(object.choreographyStartSlice)
        ? Number(object.choreographyStartSlice)
        : 0,
    };
  },

  toJSON(message: ChoreographerSave): unknown {
    const obj: any = {};
    message.choreographySequence !== undefined &&
      (obj.choreographySequence = message.choreographySequence
        ? ChoreographySequence.toJSON(message.choreographySequence)
        : undefined);
    message.musicFile !== undefined && (obj.musicFile = message.musicFile);
    message.musicStartSlice !== undefined &&
      (obj.musicStartSlice = message.musicStartSlice);
    message.choreographyStartSlice !== undefined &&
      (obj.choreographyStartSlice = message.choreographyStartSlice);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChoreographerSave>, I>>(
    object: I
  ): ChoreographerSave {
    const message = createBaseChoreographerSave();
    message.choreographySequence =
      object.choreographySequence !== undefined &&
      object.choreographySequence !== null
        ? ChoreographySequence.fromPartial(object.choreographySequence)
        : undefined;
    message.musicFile = object.musicFile ?? "";
    message.musicStartSlice = object.musicStartSlice ?? 0;
    message.choreographyStartSlice = object.choreographyStartSlice ?? 0;
    return message;
  },
};

function createBaseAnimation(): Animation {
  return {
    name: "",
    animationKeyframes: [],
    controlsArm: false,
    controlsLegs: false,
    controlsBody: false,
    controlsGripper: false,
    trackSwingTrajectories: false,
    assumeZeroRollAndPitch: false,
    armPlayback: 0,
    bpm: 0,
    retimeToIntegerSlices: false,
    minimumParameters: undefined,
    defaultParameters: undefined,
    maximumParameters: undefined,
    truncatable: false,
    extendable: false,
    neutralStart: false,
    preciseSteps: false,
    preciseTiming: false,
    armRequired: false,
    armProhibited: false,
    noLooping: false,
  };
}

export const Animation = {
  encode(
    message: Animation,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.animationKeyframes) {
      AnimationKeyframe.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.controlsArm === true) {
      writer.uint32(24).bool(message.controlsArm);
    }
    if (message.controlsLegs === true) {
      writer.uint32(32).bool(message.controlsLegs);
    }
    if (message.controlsBody === true) {
      writer.uint32(40).bool(message.controlsBody);
    }
    if (message.controlsGripper === true) {
      writer.uint32(48).bool(message.controlsGripper);
    }
    if (message.trackSwingTrajectories === true) {
      writer.uint32(128).bool(message.trackSwingTrajectories);
    }
    if (message.assumeZeroRollAndPitch === true) {
      writer.uint32(152).bool(message.assumeZeroRollAndPitch);
    }
    if (message.armPlayback !== 0) {
      writer.uint32(136).int32(message.armPlayback);
    }
    if (message.bpm !== 0) {
      writer.uint32(57).double(message.bpm);
    }
    if (message.retimeToIntegerSlices === true) {
      writer.uint32(64).bool(message.retimeToIntegerSlices);
    }
    if (message.minimumParameters !== undefined) {
      AnimateParams.encode(
        message.minimumParameters,
        writer.uint32(74).fork()
      ).ldelim();
    }
    if (message.defaultParameters !== undefined) {
      AnimateParams.encode(
        message.defaultParameters,
        writer.uint32(82).fork()
      ).ldelim();
    }
    if (message.maximumParameters !== undefined) {
      AnimateParams.encode(
        message.maximumParameters,
        writer.uint32(90).fork()
      ).ldelim();
    }
    if (message.truncatable === true) {
      writer.uint32(96).bool(message.truncatable);
    }
    if (message.extendable === true) {
      writer.uint32(104).bool(message.extendable);
    }
    if (message.neutralStart === true) {
      writer.uint32(112).bool(message.neutralStart);
    }
    if (message.preciseSteps === true) {
      writer.uint32(120).bool(message.preciseSteps);
    }
    if (message.preciseTiming === true) {
      writer.uint32(144).bool(message.preciseTiming);
    }
    if (message.armRequired === true) {
      writer.uint32(160).bool(message.armRequired);
    }
    if (message.armProhibited === true) {
      writer.uint32(176).bool(message.armProhibited);
    }
    if (message.noLooping === true) {
      writer.uint32(168).bool(message.noLooping);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Animation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.animationKeyframes.push(
            AnimationKeyframe.decode(reader, reader.uint32())
          );
          break;
        case 3:
          message.controlsArm = reader.bool();
          break;
        case 4:
          message.controlsLegs = reader.bool();
          break;
        case 5:
          message.controlsBody = reader.bool();
          break;
        case 6:
          message.controlsGripper = reader.bool();
          break;
        case 16:
          message.trackSwingTrajectories = reader.bool();
          break;
        case 19:
          message.assumeZeroRollAndPitch = reader.bool();
          break;
        case 17:
          message.armPlayback = reader.int32() as any;
          break;
        case 7:
          message.bpm = reader.double();
          break;
        case 8:
          message.retimeToIntegerSlices = reader.bool();
          break;
        case 9:
          message.minimumParameters = AnimateParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 10:
          message.defaultParameters = AnimateParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 11:
          message.maximumParameters = AnimateParams.decode(
            reader,
            reader.uint32()
          );
          break;
        case 12:
          message.truncatable = reader.bool();
          break;
        case 13:
          message.extendable = reader.bool();
          break;
        case 14:
          message.neutralStart = reader.bool();
          break;
        case 15:
          message.preciseSteps = reader.bool();
          break;
        case 18:
          message.preciseTiming = reader.bool();
          break;
        case 20:
          message.armRequired = reader.bool();
          break;
        case 22:
          message.armProhibited = reader.bool();
          break;
        case 21:
          message.noLooping = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Animation {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      animationKeyframes: Array.isArray(object?.animationKeyframes)
        ? object.animationKeyframes.map((e: any) =>
            AnimationKeyframe.fromJSON(e)
          )
        : [],
      controlsArm: isSet(object.controlsArm)
        ? Boolean(object.controlsArm)
        : false,
      controlsLegs: isSet(object.controlsLegs)
        ? Boolean(object.controlsLegs)
        : false,
      controlsBody: isSet(object.controlsBody)
        ? Boolean(object.controlsBody)
        : false,
      controlsGripper: isSet(object.controlsGripper)
        ? Boolean(object.controlsGripper)
        : false,
      trackSwingTrajectories: isSet(object.trackSwingTrajectories)
        ? Boolean(object.trackSwingTrajectories)
        : false,
      assumeZeroRollAndPitch: isSet(object.assumeZeroRollAndPitch)
        ? Boolean(object.assumeZeroRollAndPitch)
        : false,
      armPlayback: isSet(object.armPlayback)
        ? animation_ArmPlaybackFromJSON(object.armPlayback)
        : 0,
      bpm: isSet(object.bpm) ? Number(object.bpm) : 0,
      retimeToIntegerSlices: isSet(object.retimeToIntegerSlices)
        ? Boolean(object.retimeToIntegerSlices)
        : false,
      minimumParameters: isSet(object.minimumParameters)
        ? AnimateParams.fromJSON(object.minimumParameters)
        : undefined,
      defaultParameters: isSet(object.defaultParameters)
        ? AnimateParams.fromJSON(object.defaultParameters)
        : undefined,
      maximumParameters: isSet(object.maximumParameters)
        ? AnimateParams.fromJSON(object.maximumParameters)
        : undefined,
      truncatable: isSet(object.truncatable)
        ? Boolean(object.truncatable)
        : false,
      extendable: isSet(object.extendable) ? Boolean(object.extendable) : false,
      neutralStart: isSet(object.neutralStart)
        ? Boolean(object.neutralStart)
        : false,
      preciseSteps: isSet(object.preciseSteps)
        ? Boolean(object.preciseSteps)
        : false,
      preciseTiming: isSet(object.preciseTiming)
        ? Boolean(object.preciseTiming)
        : false,
      armRequired: isSet(object.armRequired)
        ? Boolean(object.armRequired)
        : false,
      armProhibited: isSet(object.armProhibited)
        ? Boolean(object.armProhibited)
        : false,
      noLooping: isSet(object.noLooping) ? Boolean(object.noLooping) : false,
    };
  },

  toJSON(message: Animation): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    if (message.animationKeyframes) {
      obj.animationKeyframes = message.animationKeyframes.map((e) =>
        e ? AnimationKeyframe.toJSON(e) : undefined
      );
    } else {
      obj.animationKeyframes = [];
    }
    message.controlsArm !== undefined &&
      (obj.controlsArm = message.controlsArm);
    message.controlsLegs !== undefined &&
      (obj.controlsLegs = message.controlsLegs);
    message.controlsBody !== undefined &&
      (obj.controlsBody = message.controlsBody);
    message.controlsGripper !== undefined &&
      (obj.controlsGripper = message.controlsGripper);
    message.trackSwingTrajectories !== undefined &&
      (obj.trackSwingTrajectories = message.trackSwingTrajectories);
    message.assumeZeroRollAndPitch !== undefined &&
      (obj.assumeZeroRollAndPitch = message.assumeZeroRollAndPitch);
    message.armPlayback !== undefined &&
      (obj.armPlayback = animation_ArmPlaybackToJSON(message.armPlayback));
    message.bpm !== undefined && (obj.bpm = message.bpm);
    message.retimeToIntegerSlices !== undefined &&
      (obj.retimeToIntegerSlices = message.retimeToIntegerSlices);
    message.minimumParameters !== undefined &&
      (obj.minimumParameters = message.minimumParameters
        ? AnimateParams.toJSON(message.minimumParameters)
        : undefined);
    message.defaultParameters !== undefined &&
      (obj.defaultParameters = message.defaultParameters
        ? AnimateParams.toJSON(message.defaultParameters)
        : undefined);
    message.maximumParameters !== undefined &&
      (obj.maximumParameters = message.maximumParameters
        ? AnimateParams.toJSON(message.maximumParameters)
        : undefined);
    message.truncatable !== undefined &&
      (obj.truncatable = message.truncatable);
    message.extendable !== undefined && (obj.extendable = message.extendable);
    message.neutralStart !== undefined &&
      (obj.neutralStart = message.neutralStart);
    message.preciseSteps !== undefined &&
      (obj.preciseSteps = message.preciseSteps);
    message.preciseTiming !== undefined &&
      (obj.preciseTiming = message.preciseTiming);
    message.armRequired !== undefined &&
      (obj.armRequired = message.armRequired);
    message.armProhibited !== undefined &&
      (obj.armProhibited = message.armProhibited);
    message.noLooping !== undefined && (obj.noLooping = message.noLooping);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Animation>, I>>(
    object: I
  ): Animation {
    const message = createBaseAnimation();
    message.name = object.name ?? "";
    message.animationKeyframes =
      object.animationKeyframes?.map((e) => AnimationKeyframe.fromPartial(e)) ||
      [];
    message.controlsArm = object.controlsArm ?? false;
    message.controlsLegs = object.controlsLegs ?? false;
    message.controlsBody = object.controlsBody ?? false;
    message.controlsGripper = object.controlsGripper ?? false;
    message.trackSwingTrajectories = object.trackSwingTrajectories ?? false;
    message.assumeZeroRollAndPitch = object.assumeZeroRollAndPitch ?? false;
    message.armPlayback = object.armPlayback ?? 0;
    message.bpm = object.bpm ?? 0;
    message.retimeToIntegerSlices = object.retimeToIntegerSlices ?? false;
    message.minimumParameters =
      object.minimumParameters !== undefined &&
      object.minimumParameters !== null
        ? AnimateParams.fromPartial(object.minimumParameters)
        : undefined;
    message.defaultParameters =
      object.defaultParameters !== undefined &&
      object.defaultParameters !== null
        ? AnimateParams.fromPartial(object.defaultParameters)
        : undefined;
    message.maximumParameters =
      object.maximumParameters !== undefined &&
      object.maximumParameters !== null
        ? AnimateParams.fromPartial(object.maximumParameters)
        : undefined;
    message.truncatable = object.truncatable ?? false;
    message.extendable = object.extendable ?? false;
    message.neutralStart = object.neutralStart ?? false;
    message.preciseSteps = object.preciseSteps ?? false;
    message.preciseTiming = object.preciseTiming ?? false;
    message.armRequired = object.armRequired ?? false;
    message.armProhibited = object.armProhibited ?? false;
    message.noLooping = object.noLooping ?? false;
    return message;
  },
};

function createBaseAnimationKeyframe(): AnimationKeyframe {
  return {
    time: 0,
    gripper: undefined,
    arm: undefined,
    body: undefined,
    legs: undefined,
  };
}

export const AnimationKeyframe = {
  encode(
    message: AnimationKeyframe,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.time !== 0) {
      writer.uint32(9).double(message.time);
    }
    if (message.gripper !== undefined) {
      AnimateGripper.encode(message.gripper, writer.uint32(18).fork()).ldelim();
    }
    if (message.arm !== undefined) {
      AnimateArm.encode(message.arm, writer.uint32(26).fork()).ldelim();
    }
    if (message.body !== undefined) {
      AnimateBody.encode(message.body, writer.uint32(34).fork()).ldelim();
    }
    if (message.legs !== undefined) {
      AnimateLegs.encode(message.legs, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimationKeyframe {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimationKeyframe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.time = reader.double();
          break;
        case 2:
          message.gripper = AnimateGripper.decode(reader, reader.uint32());
          break;
        case 3:
          message.arm = AnimateArm.decode(reader, reader.uint32());
          break;
        case 4:
          message.body = AnimateBody.decode(reader, reader.uint32());
          break;
        case 5:
          message.legs = AnimateLegs.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimationKeyframe {
    return {
      time: isSet(object.time) ? Number(object.time) : 0,
      gripper: isSet(object.gripper)
        ? AnimateGripper.fromJSON(object.gripper)
        : undefined,
      arm: isSet(object.arm) ? AnimateArm.fromJSON(object.arm) : undefined,
      body: isSet(object.body) ? AnimateBody.fromJSON(object.body) : undefined,
      legs: isSet(object.legs) ? AnimateLegs.fromJSON(object.legs) : undefined,
    };
  },

  toJSON(message: AnimationKeyframe): unknown {
    const obj: any = {};
    message.time !== undefined && (obj.time = message.time);
    message.gripper !== undefined &&
      (obj.gripper = message.gripper
        ? AnimateGripper.toJSON(message.gripper)
        : undefined);
    message.arm !== undefined &&
      (obj.arm = message.arm ? AnimateArm.toJSON(message.arm) : undefined);
    message.body !== undefined &&
      (obj.body = message.body ? AnimateBody.toJSON(message.body) : undefined);
    message.legs !== undefined &&
      (obj.legs = message.legs ? AnimateLegs.toJSON(message.legs) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimationKeyframe>, I>>(
    object: I
  ): AnimationKeyframe {
    const message = createBaseAnimationKeyframe();
    message.time = object.time ?? 0;
    message.gripper =
      object.gripper !== undefined && object.gripper !== null
        ? AnimateGripper.fromPartial(object.gripper)
        : undefined;
    message.arm =
      object.arm !== undefined && object.arm !== null
        ? AnimateArm.fromPartial(object.arm)
        : undefined;
    message.body =
      object.body !== undefined && object.body !== null
        ? AnimateBody.fromPartial(object.body)
        : undefined;
    message.legs =
      object.legs !== undefined && object.legs !== null
        ? AnimateLegs.fromPartial(object.legs)
        : undefined;
    return message;
  },
};

function createBaseAnimateGripper(): AnimateGripper {
  return { gripperAngle: undefined };
}

export const AnimateGripper = {
  encode(
    message: AnimateGripper,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gripperAngle !== undefined) {
      DoubleValue.encode(
        { value: message.gripperAngle! },
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimateGripper {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimateGripper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gripperAngle = DoubleValue.decode(
            reader,
            reader.uint32()
          ).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimateGripper {
    return {
      gripperAngle: isSet(object.gripperAngle)
        ? Number(object.gripperAngle)
        : undefined,
    };
  },

  toJSON(message: AnimateGripper): unknown {
    const obj: any = {};
    message.gripperAngle !== undefined &&
      (obj.gripperAngle = message.gripperAngle);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimateGripper>, I>>(
    object: I
  ): AnimateGripper {
    const message = createBaseAnimateGripper();
    message.gripperAngle = object.gripperAngle ?? undefined;
    return message;
  },
};

function createBaseAnimateArm(): AnimateArm {
  return { jointAngles: undefined, handPose: undefined };
}

export const AnimateArm = {
  encode(
    message: AnimateArm,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.jointAngles !== undefined) {
      ArmJointAngles.encode(
        message.jointAngles,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.handPose !== undefined) {
      AnimateArm_HandPose.encode(
        message.handPose,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimateArm {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimateArm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.jointAngles = ArmJointAngles.decode(reader, reader.uint32());
          break;
        case 2:
          message.handPose = AnimateArm_HandPose.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimateArm {
    return {
      jointAngles: isSet(object.jointAngles)
        ? ArmJointAngles.fromJSON(object.jointAngles)
        : undefined,
      handPose: isSet(object.handPose)
        ? AnimateArm_HandPose.fromJSON(object.handPose)
        : undefined,
    };
  },

  toJSON(message: AnimateArm): unknown {
    const obj: any = {};
    message.jointAngles !== undefined &&
      (obj.jointAngles = message.jointAngles
        ? ArmJointAngles.toJSON(message.jointAngles)
        : undefined);
    message.handPose !== undefined &&
      (obj.handPose = message.handPose
        ? AnimateArm_HandPose.toJSON(message.handPose)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimateArm>, I>>(
    object: I
  ): AnimateArm {
    const message = createBaseAnimateArm();
    message.jointAngles =
      object.jointAngles !== undefined && object.jointAngles !== null
        ? ArmJointAngles.fromPartial(object.jointAngles)
        : undefined;
    message.handPose =
      object.handPose !== undefined && object.handPose !== null
        ? AnimateArm_HandPose.fromPartial(object.handPose)
        : undefined;
    return message;
  },
};

function createBaseAnimateArm_HandPose(): AnimateArm_HandPose {
  return { position: undefined, eulerAngles: undefined, quaternion: undefined };
}

export const AnimateArm_HandPose = {
  encode(
    message: AnimateArm_HandPose,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.position !== undefined) {
      Vec3Value.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.eulerAngles !== undefined) {
      EulerZYXValue.encode(
        message.eulerAngles,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.quaternion !== undefined) {
      Quaternion.encode(message.quaternion, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimateArm_HandPose {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimateArm_HandPose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.position = Vec3Value.decode(reader, reader.uint32());
          break;
        case 3:
          message.eulerAngles = EulerZYXValue.decode(reader, reader.uint32());
          break;
        case 4:
          message.quaternion = Quaternion.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimateArm_HandPose {
    return {
      position: isSet(object.position)
        ? Vec3Value.fromJSON(object.position)
        : undefined,
      eulerAngles: isSet(object.eulerAngles)
        ? EulerZYXValue.fromJSON(object.eulerAngles)
        : undefined,
      quaternion: isSet(object.quaternion)
        ? Quaternion.fromJSON(object.quaternion)
        : undefined,
    };
  },

  toJSON(message: AnimateArm_HandPose): unknown {
    const obj: any = {};
    message.position !== undefined &&
      (obj.position = message.position
        ? Vec3Value.toJSON(message.position)
        : undefined);
    message.eulerAngles !== undefined &&
      (obj.eulerAngles = message.eulerAngles
        ? EulerZYXValue.toJSON(message.eulerAngles)
        : undefined);
    message.quaternion !== undefined &&
      (obj.quaternion = message.quaternion
        ? Quaternion.toJSON(message.quaternion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimateArm_HandPose>, I>>(
    object: I
  ): AnimateArm_HandPose {
    const message = createBaseAnimateArm_HandPose();
    message.position =
      object.position !== undefined && object.position !== null
        ? Vec3Value.fromPartial(object.position)
        : undefined;
    message.eulerAngles =
      object.eulerAngles !== undefined && object.eulerAngles !== null
        ? EulerZYXValue.fromPartial(object.eulerAngles)
        : undefined;
    message.quaternion =
      object.quaternion !== undefined && object.quaternion !== null
        ? Quaternion.fromPartial(object.quaternion)
        : undefined;
    return message;
  },
};

function createBaseArmJointAngles(): ArmJointAngles {
  return {
    shoulder0: undefined,
    shoulder1: undefined,
    elbow0: undefined,
    elbow1: undefined,
    wrist0: undefined,
    wrist1: undefined,
  };
}

export const ArmJointAngles = {
  encode(
    message: ArmJointAngles,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.shoulder0 !== undefined) {
      DoubleValue.encode(
        { value: message.shoulder0! },
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.shoulder1 !== undefined) {
      DoubleValue.encode(
        { value: message.shoulder1! },
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.elbow0 !== undefined) {
      DoubleValue.encode(
        { value: message.elbow0! },
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.elbow1 !== undefined) {
      DoubleValue.encode(
        { value: message.elbow1! },
        writer.uint32(34).fork()
      ).ldelim();
    }
    if (message.wrist0 !== undefined) {
      DoubleValue.encode(
        { value: message.wrist0! },
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.wrist1 !== undefined) {
      DoubleValue.encode(
        { value: message.wrist1! },
        writer.uint32(50).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArmJointAngles {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArmJointAngles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.shoulder0 = DoubleValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.shoulder1 = DoubleValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.elbow0 = DoubleValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.elbow1 = DoubleValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.wrist0 = DoubleValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.wrist1 = DoubleValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ArmJointAngles {
    return {
      shoulder0: isSet(object.shoulder0) ? Number(object.shoulder0) : undefined,
      shoulder1: isSet(object.shoulder1) ? Number(object.shoulder1) : undefined,
      elbow0: isSet(object.elbow0) ? Number(object.elbow0) : undefined,
      elbow1: isSet(object.elbow1) ? Number(object.elbow1) : undefined,
      wrist0: isSet(object.wrist0) ? Number(object.wrist0) : undefined,
      wrist1: isSet(object.wrist1) ? Number(object.wrist1) : undefined,
    };
  },

  toJSON(message: ArmJointAngles): unknown {
    const obj: any = {};
    message.shoulder0 !== undefined && (obj.shoulder0 = message.shoulder0);
    message.shoulder1 !== undefined && (obj.shoulder1 = message.shoulder1);
    message.elbow0 !== undefined && (obj.elbow0 = message.elbow0);
    message.elbow1 !== undefined && (obj.elbow1 = message.elbow1);
    message.wrist0 !== undefined && (obj.wrist0 = message.wrist0);
    message.wrist1 !== undefined && (obj.wrist1 = message.wrist1);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ArmJointAngles>, I>>(
    object: I
  ): ArmJointAngles {
    const message = createBaseArmJointAngles();
    message.shoulder0 = object.shoulder0 ?? undefined;
    message.shoulder1 = object.shoulder1 ?? undefined;
    message.elbow0 = object.elbow0 ?? undefined;
    message.elbow1 = object.elbow1 ?? undefined;
    message.wrist0 = object.wrist0 ?? undefined;
    message.wrist1 = object.wrist1 ?? undefined;
    return message;
  },
};

function createBaseAnimateBody(): AnimateBody {
  return {
    bodyPos: undefined,
    comPos: undefined,
    eulerAngles: undefined,
    quaternion: undefined,
  };
}

export const AnimateBody = {
  encode(
    message: AnimateBody,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.bodyPos !== undefined) {
      Vec3Value.encode(message.bodyPos, writer.uint32(10).fork()).ldelim();
    }
    if (message.comPos !== undefined) {
      Vec3Value.encode(message.comPos, writer.uint32(18).fork()).ldelim();
    }
    if (message.eulerAngles !== undefined) {
      EulerZYXValue.encode(
        message.eulerAngles,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.quaternion !== undefined) {
      Quaternion.encode(message.quaternion, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimateBody {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimateBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bodyPos = Vec3Value.decode(reader, reader.uint32());
          break;
        case 2:
          message.comPos = Vec3Value.decode(reader, reader.uint32());
          break;
        case 3:
          message.eulerAngles = EulerZYXValue.decode(reader, reader.uint32());
          break;
        case 4:
          message.quaternion = Quaternion.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimateBody {
    return {
      bodyPos: isSet(object.bodyPos)
        ? Vec3Value.fromJSON(object.bodyPos)
        : undefined,
      comPos: isSet(object.comPos)
        ? Vec3Value.fromJSON(object.comPos)
        : undefined,
      eulerAngles: isSet(object.eulerAngles)
        ? EulerZYXValue.fromJSON(object.eulerAngles)
        : undefined,
      quaternion: isSet(object.quaternion)
        ? Quaternion.fromJSON(object.quaternion)
        : undefined,
    };
  },

  toJSON(message: AnimateBody): unknown {
    const obj: any = {};
    message.bodyPos !== undefined &&
      (obj.bodyPos = message.bodyPos
        ? Vec3Value.toJSON(message.bodyPos)
        : undefined);
    message.comPos !== undefined &&
      (obj.comPos = message.comPos
        ? Vec3Value.toJSON(message.comPos)
        : undefined);
    message.eulerAngles !== undefined &&
      (obj.eulerAngles = message.eulerAngles
        ? EulerZYXValue.toJSON(message.eulerAngles)
        : undefined);
    message.quaternion !== undefined &&
      (obj.quaternion = message.quaternion
        ? Quaternion.toJSON(message.quaternion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimateBody>, I>>(
    object: I
  ): AnimateBody {
    const message = createBaseAnimateBody();
    message.bodyPos =
      object.bodyPos !== undefined && object.bodyPos !== null
        ? Vec3Value.fromPartial(object.bodyPos)
        : undefined;
    message.comPos =
      object.comPos !== undefined && object.comPos !== null
        ? Vec3Value.fromPartial(object.comPos)
        : undefined;
    message.eulerAngles =
      object.eulerAngles !== undefined && object.eulerAngles !== null
        ? EulerZYXValue.fromPartial(object.eulerAngles)
        : undefined;
    message.quaternion =
      object.quaternion !== undefined && object.quaternion !== null
        ? Quaternion.fromPartial(object.quaternion)
        : undefined;
    return message;
  },
};

function createBaseAnimateLegs(): AnimateLegs {
  return { fl: undefined, fr: undefined, hl: undefined, hr: undefined };
}

export const AnimateLegs = {
  encode(
    message: AnimateLegs,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.fl !== undefined) {
      AnimateSingleLeg.encode(message.fl, writer.uint32(10).fork()).ldelim();
    }
    if (message.fr !== undefined) {
      AnimateSingleLeg.encode(message.fr, writer.uint32(18).fork()).ldelim();
    }
    if (message.hl !== undefined) {
      AnimateSingleLeg.encode(message.hl, writer.uint32(26).fork()).ldelim();
    }
    if (message.hr !== undefined) {
      AnimateSingleLeg.encode(message.hr, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimateLegs {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimateLegs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fl = AnimateSingleLeg.decode(reader, reader.uint32());
          break;
        case 2:
          message.fr = AnimateSingleLeg.decode(reader, reader.uint32());
          break;
        case 3:
          message.hl = AnimateSingleLeg.decode(reader, reader.uint32());
          break;
        case 4:
          message.hr = AnimateSingleLeg.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimateLegs {
    return {
      fl: isSet(object.fl) ? AnimateSingleLeg.fromJSON(object.fl) : undefined,
      fr: isSet(object.fr) ? AnimateSingleLeg.fromJSON(object.fr) : undefined,
      hl: isSet(object.hl) ? AnimateSingleLeg.fromJSON(object.hl) : undefined,
      hr: isSet(object.hr) ? AnimateSingleLeg.fromJSON(object.hr) : undefined,
    };
  },

  toJSON(message: AnimateLegs): unknown {
    const obj: any = {};
    message.fl !== undefined &&
      (obj.fl = message.fl ? AnimateSingleLeg.toJSON(message.fl) : undefined);
    message.fr !== undefined &&
      (obj.fr = message.fr ? AnimateSingleLeg.toJSON(message.fr) : undefined);
    message.hl !== undefined &&
      (obj.hl = message.hl ? AnimateSingleLeg.toJSON(message.hl) : undefined);
    message.hr !== undefined &&
      (obj.hr = message.hr ? AnimateSingleLeg.toJSON(message.hr) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimateLegs>, I>>(
    object: I
  ): AnimateLegs {
    const message = createBaseAnimateLegs();
    message.fl =
      object.fl !== undefined && object.fl !== null
        ? AnimateSingleLeg.fromPartial(object.fl)
        : undefined;
    message.fr =
      object.fr !== undefined && object.fr !== null
        ? AnimateSingleLeg.fromPartial(object.fr)
        : undefined;
    message.hl =
      object.hl !== undefined && object.hl !== null
        ? AnimateSingleLeg.fromPartial(object.hl)
        : undefined;
    message.hr =
      object.hr !== undefined && object.hr !== null
        ? AnimateSingleLeg.fromPartial(object.hr)
        : undefined;
    return message;
  },
};

function createBaseAnimateSingleLeg(): AnimateSingleLeg {
  return { jointAngles: undefined, footPos: undefined, stance: undefined };
}

export const AnimateSingleLeg = {
  encode(
    message: AnimateSingleLeg,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.jointAngles !== undefined) {
      LegJointAngles.encode(
        message.jointAngles,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.footPos !== undefined) {
      Vec3Value.encode(message.footPos, writer.uint32(18).fork()).ldelim();
    }
    if (message.stance !== undefined) {
      BoolValue.encode(
        { value: message.stance! },
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimateSingleLeg {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimateSingleLeg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.jointAngles = LegJointAngles.decode(reader, reader.uint32());
          break;
        case 2:
          message.footPos = Vec3Value.decode(reader, reader.uint32());
          break;
        case 3:
          message.stance = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimateSingleLeg {
    return {
      jointAngles: isSet(object.jointAngles)
        ? LegJointAngles.fromJSON(object.jointAngles)
        : undefined,
      footPos: isSet(object.footPos)
        ? Vec3Value.fromJSON(object.footPos)
        : undefined,
      stance: isSet(object.stance) ? Boolean(object.stance) : undefined,
    };
  },

  toJSON(message: AnimateSingleLeg): unknown {
    const obj: any = {};
    message.jointAngles !== undefined &&
      (obj.jointAngles = message.jointAngles
        ? LegJointAngles.toJSON(message.jointAngles)
        : undefined);
    message.footPos !== undefined &&
      (obj.footPos = message.footPos
        ? Vec3Value.toJSON(message.footPos)
        : undefined);
    message.stance !== undefined && (obj.stance = message.stance);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimateSingleLeg>, I>>(
    object: I
  ): AnimateSingleLeg {
    const message = createBaseAnimateSingleLeg();
    message.jointAngles =
      object.jointAngles !== undefined && object.jointAngles !== null
        ? LegJointAngles.fromPartial(object.jointAngles)
        : undefined;
    message.footPos =
      object.footPos !== undefined && object.footPos !== null
        ? Vec3Value.fromPartial(object.footPos)
        : undefined;
    message.stance = object.stance ?? undefined;
    return message;
  },
};

function createBaseLegJointAngles(): LegJointAngles {
  return { hipX: 0, hipY: 0, knee: 0 };
}

export const LegJointAngles = {
  encode(
    message: LegJointAngles,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.hipX !== 0) {
      writer.uint32(9).double(message.hipX);
    }
    if (message.hipY !== 0) {
      writer.uint32(17).double(message.hipY);
    }
    if (message.knee !== 0) {
      writer.uint32(25).double(message.knee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LegJointAngles {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLegJointAngles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hipX = reader.double();
          break;
        case 2:
          message.hipY = reader.double();
          break;
        case 3:
          message.knee = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LegJointAngles {
    return {
      hipX: isSet(object.hipX) ? Number(object.hipX) : 0,
      hipY: isSet(object.hipY) ? Number(object.hipY) : 0,
      knee: isSet(object.knee) ? Number(object.knee) : 0,
    };
  },

  toJSON(message: LegJointAngles): unknown {
    const obj: any = {};
    message.hipX !== undefined && (obj.hipX = message.hipX);
    message.hipY !== undefined && (obj.hipY = message.hipY);
    message.knee !== undefined && (obj.knee = message.knee);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LegJointAngles>, I>>(
    object: I
  ): LegJointAngles {
    const message = createBaseLegJointAngles();
    message.hipX = object.hipX ?? 0;
    message.hipY = object.hipY ?? 0;
    message.knee = object.knee ?? 0;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
